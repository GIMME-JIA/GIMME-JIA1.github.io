[{"title":"数据结构——递归","path":"/2023/12/11/数据结构--递归/","content":"1) 概述 定义 计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集 In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. 说明： 自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的） 每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归 内层函数调用（子集处理）完成，外层函数才能算调用完成 思路 确定能否使用递归求解 推导出递推关系，即父问题与子问题的关系，以及递归的结束条件 深入到最里层叫做递 从最里层出来叫做归 在递的过程中，外层函数内的局部变量（以及方法参数）并未消失，归的时候还可以用到 2) 单路递归 Single Recursion E01. 阶乘 用递归方法求阶乘 阶乘的定义 n!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅nn!= 1⋅2⋅3⋯(n-2)⋅(n-1)⋅nn!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅n，其中 nnn 为自然数，当然 0!=10! = 10!=1 递推关系 f(n)={1n=1n∗f(n−1)n&gt;1f(n) = \\begin{cases} 1 &amp; n = 1\\\\ n * f(n-1) &amp; n &gt; 1 \\end{cases} f(n)={1n∗f(n−1)​n=1n&gt;1​ 代码 123456private static int f(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * f(n - 1);&#125; E02. 反向打印字符串 用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置 递：n 从 0 开始，每次 n + 1，一直递到 n == str.length() - 1 归：从 n == str.length() 开始归，从归打印，自然是逆序的 递推关系 f(n)={停止n=str.length()f(n+1)0≤n≤str.length()−1f(n) = \\begin{cases} 停止 &amp; n = str.length() \\\\ f(n+1) &amp; 0 \\leq n \\leq str.length() - 1 \\end{cases} f(n)={停止f(n+1)​n=str.length()0≤n≤str.length()−1​ 代码为 1234567public static void reversePrint(String str, int index) &#123; if (index == str.length()) &#123; return; &#125; reversePrint(str, index + 1); System.out.println(str.charAt(index));&#125; E03. 二分查找（单路递归） 1234567891011121314151617public static int binarySearch(int[] a, int target) &#123; return recursion(a, target, 0, a.length - 1);&#125;public static int recursion(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return recursion(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return recursion(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; E04. 冒泡排序（单路递归） 12345678910111213141516171819202122232425public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 4, 7&#125;; bubble(a, 0, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void bubble(int[] a, int low, int high) &#123; if(low == high) &#123; return; &#125; int j = low; for (int i = low; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); j = i; // j将指向右边最大的元素，即右边界 &#125; &#125; bubble(a, low, j);&#125;private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125; low 与 high 为未排序范围 j 表示的是未排序的边界，下一次递归时的 high 发生交换，意味着有无序情况 最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1 已然有序 E05. 插入排序（单路递归） 123456789101112131415161718192021public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 7, 4&#125;; insertion(a, 1, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void insertion(int[] a, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low - 1; int t = a[low]; while (i &gt;= 0 &amp;&amp; a[i] &gt; i) &#123; a[i + 1] = a[i]; i--; &#125; if(i + 1 != low) &#123; a[i + 1] = t; &#125; insertion(a, low + 1, high);&#125; 已排序区域：[0 … i … low-1] 未排序区域：[low … high] E06. 约瑟夫问题（单路递归） nnn 个人排成圆圈，从头开始报数，每次数到第 mmm 个人（mmm 从 111 开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？ 方法1 根据最后的存活者 a 倒推出它在上一轮的索引号 f(n,m) 本轮索引 为了让 a 是这个索引，上一轮应当这样排 规律 f(1,3) 0 x x x a (0 + 3) % 2 f(2,3) 1 x x x 0 a (1 + 3) % 3 f(3,3) 1 x x x 0 a (1 + 3) % 4 f(4,3) 0 x x x a (0 + 3) % 5 f(5,3) 3 x x x 0 1 2 a (3 + 3) % 6 f(6,3) 0 x x x a 方法2 设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始 f(n, m) 解 规律 f(1, 3) 0 f(2, 3) 0 1 =&gt; 1 3%2=1 f(3, 3) 0 1 2 =&gt; 0 1 3%3=0 f(4, 3) 0 1 2 3 =&gt; 3 0 1 3%4=3 f(5, 3) 0 1 2 3 4 =&gt; 3 4 0 1 3%5=3 f(6, 3) 0 1 2 3 4 5 =&gt; 3 4 5 0 1 3%6=3 一. 找出等价函数 规律：下次报数的起点为 k=m%nk = m \\% nk=m%n 首次出列人的序号是 k−1k-1k−1，剩下的的 n−1n-1n−1 个人重新组成约瑟夫环 下次从 kkk 开始数，序号如下 k, k+1, ... , 0, 1, k−2k,\\ k+1, \\ ...\\ ,\\ 0,\\ 1,\\ k-2k, k+1, ... , 0, 1, k−2，如上例中 3 4 5 0 13\\ 4\\ 5\\ 0\\ 13 4 5 0 1 这个函数称之为 g(n−1,m)g(n-1,m)g(n−1,m)，它的最终结果与 f(n,m)f(n,m)f(n,m) 是相同的。 二. 找到映射函数 现在想办法找到 g(n−1,m)g(n-1,m)g(n−1,m) 与 f(n−1,m)f(n-1, m)f(n−1,m) 的对应关系，即 3→04→15→20→31→43 \\rightarrow 0 \\\\ 4 \\rightarrow 1 \\\\ 5 \\rightarrow 2 \\\\ 0 \\rightarrow 3 \\\\ 1 \\rightarrow 4 \\\\ 3→04→15→20→31→4 映射函数为 mapping(x)={x−kx=[k..n−1]x+n−kx=[0..k−2]mapping(x) = \\begin{cases} x-k &amp; x=[k..n-1] \\\\ x+n-k &amp; x=[0..k-2] \\end{cases} mapping(x)={x−kx+n−k​x=[k..n−1]x=[0..k−2]​ 等价于下面函数 mapping(x)=(x+n−k)%nmapping(x) = (x + n - k)\\%{n} mapping(x)=(x+n−k)%n 代入测试一下 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→43 \\rightarrow (3+6-3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+6-3)\\%6 \\rightarrow 1 \\\\ 5 \\rightarrow (5+6-3)\\%6 \\rightarrow 2 \\\\ 0 \\rightarrow (0+6-3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+6-3)\\%6 \\rightarrow 4 \\\\ 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→4 综上有 f(n−1,m)=mapping(g(n−1,m))f(n-1,m) = mapping(g(n-1,m)) f(n−1,m)=mapping(g(n−1,m)) 三. 求逆映射函数 映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x mapping−1(x)=(x+k)%nmapping^{-1}(x) = (x + k)\\%n mapping−1(x)=(x+k)%n 代入测试一下 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→10 \\rightarrow (0+3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+3)\\%6 \\rightarrow 4 \\\\ 2 \\rightarrow (2+3)\\%6 \\rightarrow 5 \\\\ 3 \\rightarrow (3+3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+3)\\%6 \\rightarrow 1 \\\\ 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→1 因此可以求得 g(n−1,m)=mapping−1(f(n−1,m))g(n-1,m) = mapping^{-1}(f(n-1,m)) g(n−1,m)=mapping−1(f(n−1,m)) 四. 递推式 代入推导 f(n,m)= g(n−1,m)= mapping−1(f(n−1,m))= (f(n−1,m)+k)%n= (f(n−1,m)+m%n)%n= (f(n−1,m)+m)%n\\begin{aligned} f(n,m) = \\ &amp; g(n-1,m) \\\\ = \\ &amp; mapping^{-1}(f(n-1,m)) \\\\ = \\ &amp; (f(n-1,m) + k) \\% n \\\\ = \\ &amp; (f(n-1,m) + m\\%n) \\% n \\\\ = \\ &amp; (f(n-1,m) + m) \\% n \\\\ \\end{aligned} f(n,m)= = = = = ​g(n−1,m)mapping−1(f(n−1,m))(f(n−1,m)+k)%n(f(n−1,m)+m%n)%n(f(n−1,m)+m)%n​ 最后一步化简是利用了模运算法则 (a+b)%n=(a%n+b%n)%n(a+b)\\%n = (a\\%n + b\\%n) \\%n(a+b)%n=(a%n+b%n)%n 例如 (6+6)%5=2=(6+6%5)%5(6+6)\\%5 = 2 = (6+6\\%5)\\%5(6+6)%5=2=(6+6%5)%5 (6+5)%5=1=(6+5%5)%5(6+5)\\%5 = 1 = (6+5\\%5)\\%5(6+5)%5=1=(6+5%5)%5 (6+4)%5=0=(6+4%5)%5(6+4)\\%5 = 0 = (6+4\\%5)\\%5(6+4)%5=0=(6+4%5)%5 最终递推式 f(n,m)={(f(n−1,m)+m)%nn&gt;10n=1f(n,m) = \\begin{cases} (f(n-1,m) + m) \\% n &amp; n&gt;1\\\\ 0 &amp; n = 1 \\end{cases} f(n,m)={(f(n−1,m)+m)%n0​n&gt;1n=1​ 3) 多路递归 Multi Recursion E01. 斐波那契数列 之前的例子是每个递归函数只包含一个自身的调用，这称之为 single recursion 如果每个递归函数例包含多个自身调用，称之为 multi recursion 递推关系 f(n)={0n=01n=1f(n−1)+f(n−2)n&gt;1f(n) = \\begin{cases} 0 &amp; n=0 \\\\ 1 &amp; n=1 \\\\ f(n-1) + f(n-2) &amp; n&gt;1 \\end{cases} f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n&gt;1​ 下面的表格列出了数列的前几项 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 0 1 1 2 3 5 8 13 21 34 55 89 144 233 实现 123456789public static int f(int n) &#123; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; return f(n - 1) + f(n - 2);&#125; 执行流程 绿色代表正在执行（对应递），灰色代表执行结束（对应归） 递不到头，不能归，对应着深度优先搜索 时间复杂度 递归的次数也符合斐波那契规律，2∗f(n+1)−12 * f(n+1)-12∗f(n+1)−1 时间复杂度推导过程 斐波那契通项公式 f(n)=15∗(1+52n−1−52n)f(n) = \\frac{1}{\\sqrt{5}}*({\\frac{1+\\sqrt{5}}{2}}^n - {\\frac{1-\\sqrt{5}}{2}}^n)f(n)=5​1​∗(21+5​​n−21−5​​n) 简化为：f(n)=12.236∗(1.618n−(−0.618)n)f(n) = \\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)f(n)=2.2361​∗(1.618n−(−0.618)n) 带入递归次数公式 2∗12.236∗(1.618n+1−(−0.618)n+1)−12*\\frac{1}{2.236}*({1.618}^{n+1} - {(-0.618)}^{n+1})-12∗2.2361​∗(1.618n+1−(−0.618)n+1)−1 时间复杂度为 Θ(1.618n)\\Theta(1.618^n)Θ(1.618n) 更多 Fibonacci 参考[8][9][^10] 以上时间复杂度分析，未考虑大数相加的因素 变体1 - 兔子问题 第一个月，有一对未成熟的兔子（黑色，注意图中个头较小） 第二个月，它们成熟 第三个月，它们能产下一对新的小兔子（蓝色） 所有兔子遵循相同规律，求第 nnn 个月的兔子数 分析 兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 f(n)f(n)f(n) f(n)f(n)f(n) = 上个月兔子数 + 新生的小兔子数 而【新生的小兔子数】实际就是【上个月成熟的兔子数】 因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】 上个月兔子数，即 f(n−1)f(n-1)f(n−1) 上上个月的兔子数，即 f(n−2)f(n-2)f(n−2) 因此本质还是斐波那契数列，只是从其第一项开始 变体2 - 青蛙爬楼梯 楼梯有 nnn 阶 青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶 只能向上跳，问有多少种跳法 分析 n 跳法 规律 1 (1) 暂时看不出 2 (1,1) (2) 暂时看不出 3 (1,1,1) (1,2) (2,1) 暂时看不出 4 (1,1,1,1) (1,2,1) (2,1,1)(1,1,2) (2,2) 最后一跳，跳一个台阶的，基于f(3)最后一跳，跳两个台阶的，基于f(2) 5 … … 因此本质上还是斐波那契数列，只是从其第二项开始 E02. 汉诺塔（多路递归） Tower of Hanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着 64 片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定 一次只能移动一个圆盘 小圆盘上不能放大圆盘 下面的动图演示了4片圆盘的移动方法 E03. 杨辉三角 优化1 在multiple recursion过程中，有很多 ，因此很多递归调用是重复的，用 memoization 来进行优化： 123456789101112131415161718192021222324public static void print1(int n) &#123; int[][] triangle = new int[n][]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 triangle[i] = new int[i + 1]; for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, element1(triangle, i, j)); &#125; System.out.println(); &#125;&#125;public static int element1(int[][] triangle, int i, int j) &#123; if (triangle[i][j] &gt; 0) &#123; return triangle[i][j]; &#125; if (j == 0 || i == j) &#123; triangle[i][j] = 1; return triangle[i][j]; &#125; triangle[i][j] = element1(triangle, i - 1, j - 1) + element1(triangle, i - 1, j); return triangle[i][j];&#125; 将数组作为递归函数内可以访问的遍历，如果 triangle[i][j]triangle[i][j]triangle[i][j] 已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了 优化2 123456789101112131415161718192021public static void print2(int n) &#123; int[] row = new int[n]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 createRow(row, i); for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, row[j]); &#125; System.out.println(); &#125;&#125;private static void createRow(int[] row, int i) &#123; if (i == 0) &#123; row[0] = 1; return; &#125; for (int j = i; j &gt; 0; j--) &#123; row[j] = row[j - 1] + row[j]; &#125;&#125; 4) 递归优化-记忆法 Memoization 记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码 1234567891011121314151617public static void main(String[] args) &#123; int n = 13; int[] cache = new int[n + 1]; Arrays.fill(cache, -1); cache[0] = 0; cache[1] = 1; System.out.println(f(cache, n));&#125;public static int f(int[] cache, int n) &#123; if (cache[n] != -1) &#123; return cache[n]; &#125; cache[n] = f(cache, n - 1) + f(cache, n - 2); return cache[n];&#125; 优化后的图示，只要结果被缓存，就不会执行其子问题 改进后的时间复杂度为 O(n)O(n)O(n) 注意 记忆法是动态规划的一种情况，强调的是自顶向下的解决 记忆法的本质是空间换时间 5) 递归优化-尾递归 爆栈 每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等 方法调用占用的内存需要等到方法结束时才会释放 而递归调用过程中，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了 尾调用 如果函数的最后一步是调用一个函数，那么称为尾调用 尾递归 尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数 尾递归避免爆栈 Java目前还不支持，但可以在IDEA插件安装 Scala 12345object Main &#123; def main(args: Array[String]): Unit = &#123; println(&quot;Hello Scala&quot;) &#125;&#125; Scala中，java 中的类都可以拿来重用 类型是放在变量后面的 Unit 表示无返回值，类似于 void 不需要以分号作为结尾，当然加上也对 Scala 最后一行代码若作为返回值，可以省略 return 代码如下 1234567@tailrecdef sum(n: Long, accumulator: Long): Long = &#123; if (n == 1) &#123; return 1 + accumulator &#125; return sum(n - 1, n + accumulator)&#125; accumulator 作为累加器 @tailrec 注解是 scala 提供的，用来检查方法是否符合尾递归 本质上，尾递归优化是将函数的递归调用，变成了函数的循环调用，可以在java中改为循坏避免爆栈问题 6) 递归时间复杂度-Master theorem 若有递归式 T(n)=aT(nb)+f(n)T(n) = aT(\\frac{n}{b}) + f(n) T(n)=aT(bn​)+f(n) 其中 T(n)T(n)T(n) 是问题的运行时间，nnn 是数据规模 aaa 是子问题个数 T(nb)T(\\frac{n}{b})T(bn​) 是子问题运行时间，每个子问题被拆成原问题数据规模的 nb\\frac{n}{b}bn​ f(n)f(n)f(n) 是除递归外执行的计算 令 x=log⁡bax = \\log_{b}{a}x=logb​a，即 x=log⁡子问题缩小倍数子问题个数x = \\log_{子问题缩小倍数}{子问题个数}x=log子问题缩小倍数​子问题个数 那么 T(n)={Θ(nx)f(n)=O(nc)并且c&lt;xΘ(nxlog⁡n)f(n)=Θ(nx)Θ(nc)f(n)=Ω(nc)并且c&gt;xT(n) = \\begin{cases} \\Theta(n^x) &amp; f(n) = O(n^c) 并且 c \\lt x\\\\ \\Theta(n^x\\log{n}) &amp; f(n) = \\Theta(n^x)\\\\ \\Theta(n^c) &amp; f(n) = \\Omega(n^c) 并且 c \\gt x \\end{cases} T(n)=⎩⎨⎧​Θ(nx)Θ(nxlogn)Θ(nc)​f(n)=O(nc)并且c&lt;xf(n)=Θ(nx)f(n)=Ω(nc)并且c&gt;x​ 例1 T(n)=2T(n2)+n4T(n) = 2T(\\frac{n}{2}) + n^4T(n)=2T(2n​)+n4 此时 x=1&lt;4x = 1 &lt; 4x=1&lt;4，由后者决定整个时间复杂度 Θ(n4)\\Theta(n^4)Θ(n4) 如果觉得对数不好算，可以换为求【bbb 的几次方能等于 aaa】 例2 T(n)=T(7n10)+nT(n) = T(\\frac{7n}{10}) + nT(n)=T(107n​)+n a=1,b=107,x=0,c=1a=1, b=\\frac{10}{7}, x=0, c=1a=1,b=710​,x=0,c=1 此时 x=0&lt;1x = 0 &lt; 1x=0&lt;1，由后者决定整个时间复杂度 Θ(n)\\Theta(n)Θ(n) 例3 T(n)=16T(n4)+n2T(n) = 16T(\\frac{n}{4}) + n^2T(n)=16T(4n​)+n2 a=16,b=4,x=2,c=2a=16, b=4, x=2, c=2a=16,b=4,x=2,c=2 此时 x=2=cx=2 = cx=2=c，时间复杂度 Θ(n2log⁡n)\\Theta(n^2 \\log{n})Θ(n2logn) 例4 T(n)=7T(n3)+n2T(n)=7T(\\frac{n}{3}) + n^2T(n)=7T(3n​)+n2 a=7,b=3,x=1.?,c=2a=7, b=3, x=1.?, c=2a=7,b=3,x=1.?,c=2 此时 x=log⁡37&lt;2x = \\log_{3}{7} &lt; 2x=log3​7&lt;2，由后者决定整个时间复杂度 Θ(n2)\\Theta(n^2)Θ(n2) 例5 T(n)=7T(n2)+n2T(n) = 7T(\\frac{n}{2}) + n^2T(n)=7T(2n​)+n2 a=7,b=2,x=2.?,c=2a=7, b=2, x=2.?, c=2a=7,b=2,x=2.?,c=2 此时 x=log27&gt;2x = log_2{7} &gt; 2x=log2​7&gt;2，由前者决定整个时间复杂度 Θ(nlog⁡27)\\Theta(n^{\\log_2{7}})Θ(nlog2​7) 例6 T(n)=2T(n4)+nT(n) = 2T(\\frac{n}{4}) + \\sqrt{n}T(n)=2T(4n​)+n​ a=2,b=4,x=0.5,c=0.5a=2, b=4, x = 0.5, c=0.5a=2,b=4,x=0.5,c=0.5 此时 x=0.5=cx = 0.5 = cx=0.5=c，时间复杂度 Θ(nlog⁡n)\\Theta(\\sqrt{n}\\log{n})Θ(n​logn) 7) 递归时间复杂度-展开求解 像下面的递归式，都不能用主定理求解 例1 - 递归求和 123456long sum(long n) &#123; if (n == 1) &#123; return 1; &#125; return n + sum(n - 1);&#125; T(n)=T(n−1)+cT(n) = T(n-1) + cT(n)=T(n−1)+c，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+c+cT(n) = T(n-2) + c + cT(n)=T(n−2)+c+c T(n)=T(n−3)+c+c+cT(n) = T(n-3) + c + c + cT(n)=T(n−3)+c+c+c … T(n)=T(n−(n−1))+(n−1)cT(n) = T(n-(n-1)) + (n-1)cT(n)=T(n−(n−1))+(n−1)c 其中 T(n−(n−1))T(n-(n-1))T(n−(n−1)) 即 T(1)T(1)T(1) 带入求得 T(n)=c+(n−1)c=ncT(n) = c + (n-1)c = ncT(n)=c+(n−1)c=nc 时间复杂度为 O(n)O(n)O(n) 例2 - 递归冒泡排序 1234567891011void bubble(int[] a, int high) &#123; if(0 == high) &#123; return; &#125; for (int i = 0; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); &#125; &#125; bubble(a, high - 1);&#125; T(n)=T(n−1)+nT(n) = T(n-1) + nT(n)=T(n−1)+n，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+(n−1)+nT(n) = T(n-2) + (n-1) + nT(n)=T(n−2)+(n−1)+n T(n)=T(n−3)+(n−2)+(n−1)+nT(n) = T(n-3) + (n-2) + (n-1) + nT(n)=T(n−3)+(n−2)+(n−1)+n … T(n)=T(1)+2+...+n=T(1)+(n−1)2+n2=c+n22+n2−1T(n) = T(1) + 2 + ... + n = T(1) + (n-1)\\frac{2+n}{2} = c + \\frac{n^2}{2} + \\frac{n}{2} -1T(n)=T(1)+2+...+n=T(1)+(n−1)22+n​=c+2n2​+2n​−1 时间复杂度 O(n2)O(n^2)O(n2) 注： 等差数列求和为 个数∗∣首项−末项∣2个数*\\frac{\\vert首项-末项\\vert}{2}个数∗2∣首项−末项∣​ 可用该站进行公式推导：https://www.wolframalpha.com/","tags":["数据结构"],"categories":["学习笔记"]},{"title":"b","path":"/2023/11/24/b/","content":"还行 不是 啊 这 不是吧 哦哦"},{"title":"a","path":"/2023/11/23/a/","content":"我是一只小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的","tags":["Java"],"categories":["技术随笔"]},{"title":"Redis--基础","path":"/2023/11/08/Redis--基础/","content":"1.Redis简单介绍 Redis是一种键值型的NoSql数据库，这里有两个关键字： 键值型 NoSql 其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json。 而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。 对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。 2.初识Redis 2.1.认识NoSQL NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 2.1.1.结构化与非结构化 传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。 而NoSql则对数据库格式没有严格约束，往往形式松散，自由。 可以是键值型，也可以是文档型，甚至可以是图格式。 2.1.2.关联和非关联 传统数据库的表与表之间往往存在关联，例如外键： 而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合： 123456789101112131415161718&#123; id: 1, name: &quot;张三&quot;, orders: [ &#123; id: 1, item: &#123; id: 10, title: &quot;荣耀6&quot;, price: 4999 &#125; &#125;, &#123; id: 2, item: &#123; id: 20, title: &quot;小米11&quot;, price: 3999 &#125; &#125; ]&#125; 此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。 2.1.3.查询方式 传统关系型数据库会基于Sql语句做查询，语法有统一标准； 而不同的非关系数据库查询语法差异极大，五花八门各种各样。 2.1.4.事务 传统关系型数据库能满足事务ACID的原则。 而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。 2.1.5.总结 除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下： 存储方式 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些 扩展性 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦 2.2.认识Redis Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存.IO多路复用.良好的编码）。 支持数据持久化 支持主从集群.分片集群 支持多语言客户端 Redis的官方网站地址：https://redis.io/ 3.Redis常见命令 3.1 Redis数据结构介绍 Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令，也可以执行该命令进入容器执行命令。 1docker exec -it &lt;container_name_or_id&gt; redis-cli 3.2 Redis 通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL(Time To Live，生存时间)：查看一个KEY的剩余有效期 通过help [command] 可以查看一个命令的具体用法。 代码如下 KEYS 123456789127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt; 提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 DEL 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1 #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;\t#只剩下一个了127.0.0.1:6379&gt; 提示：在拷贝代码的时候，只需要拷贝对应的命令 EXISTS 123456789101112127.0.0.1:6379&gt; help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE 提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除 1234567891011127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1 # ttl的返回值就是-1 3.3 Redis命令-String命令 String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 String的常见命令有： SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（必须指定增长步长） SETNX(set not exit)：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX(set key expire time)：添加一个String类型的键值对，并且指定有效期 提示：以上命令除了INCRBYFLOAT 都是常用命令，且有一些组合命令如SETNX,SETEX. SET 和GET: 如果key不存在则是新增，如果存在则是修改 1234567891011127.0.0.1:6379&gt; set name Rose //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot; MSET和MGET 123456789127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot; //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot; INCR和INCRBY和DECY 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11 127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值 127.0.0.1:6379&gt; incrby age 2(integer) 15 127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14 127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12 127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11 127.0.0.1:6379&gt; get age &quot;11&quot; SETNX 1234567891011121314151617127.0.0.1:6379&gt; help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string127.0.0.1:6379&gt; set name Jack //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot; SETEX 12345678127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7 3.4 Redis命令-Key的层级结构 Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:'隔开，格式如下： **项目名：业务名：类型：id** 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于文件夹的结构，更加方便Redis获取数据。 3.5 Redis命令-Hash命令 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。 Hash类型的常见命令 HSET key field value：添加或者修改hash类型key的field的值 HGET key field：获取一个hash类型key的field的值 HMSET：批量获取多个hash类型key的field的值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有的field HVALS：获取一个hash类型的key中的所有的field的值 HINCRBY:让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 提示：哈希结构也是实际开发中常用的命令 HSET和HGET 12345678910127.0.0.1:6379&gt; HSET user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET user:3 age&quot;17&quot; HMSET和HMGET 12345678127.0.0.1:6379&gt; HMSET user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HGETALL 1234567127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot; HKEYS和HVALS 12345678127.0.0.1:6379&gt; HKEYS user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HINCRBY 12345678127.0.0.1:6379&gt; HINCRBY user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY user:4 age -2(integer) 20 HSETNX 12345678910111213141516127.0.0.1:6379&gt; HSETNX user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot; 3.6 Redis命令-List命令 Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element … ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素，start表示起始索引，end表示结束索引 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil LPUSH和RPUSH 1234127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6 LPOP和RPOP 1234127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot; LRANGE 123127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot; 3.7 Redis命令-Set命令 Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set类型的常见命令 SADD key member … ：向set中添加一个或多个元素 SREM key member … : 移除set中的指定元素 SCARD key： 返回set中元素的个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2 … ：求key1与key2的交集 SDIFF key1 key2 … ：求key1与key2的差集 SUNION key1 key2 …：求key1和key2的并集 例如两个集合：s1和s2: 求交集：SINTER s1 s2 求s1与s2的不同：SDIFF s1 s2 具体命令 1234567891011121314151617127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1 127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0 127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1 127.0.0.1:6379&gt; SCARD s1(integer) 2 3.8 Redis命令-SortedSet类型 Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member : 获取sorted set中的指定元素的score值 ZRANK key member：获取sorted set 中的指定元素的排名 ZCARD key：获取sorted set中的元素个数 ZCOUNT key min max：统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max：按照score排序后，获取指定排名范围内的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF.ZINTER.ZUNION：求差集.交集.并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 4.Redis的Java客户端-Jedis 在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。 4.1 Jedis快速入门 入门案例详细步骤 案例分析： 0）创建工程： 1）引入依赖： 12345678910111213&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）建立连接 新建一个单元测试类，内容如下： 123456789101112private Jedis jedis;@BeforeEachvoid setUp() &#123; // 1.建立连接 // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(&quot;123321&quot;); // 3.选择库 jedis.select(0);&#125; 3）测试： 1234567891011121314151617181920@Testvoid testString() &#123; // 存入数据 String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123; // 插入hash数据 jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;); jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;); // 获取 Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;); System.out.println(map);&#125;} 4）释放资源 123456@AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125;} 4.2 Jedis连接池 Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如tomcat中的线程池，这些都是池化思想的体现。 4.2.1.创建Jedis的连接池 1234567891011121314151617181920public class JedisConnectionFacotry &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;} 代码说明： 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，可以使用工厂，去降低耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3）最后提供返回连接池中连接的方法. 4.2.2.改造原始代码 代码说明: 1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。 ，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。 2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。 123456789101112131415 @BeforeEach void setUp()&#123; //建立连接 /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); &#125;@AfterEach void tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;} 5.Redis的Java客户端-SpringDataRedis SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 5.1.快速入门 SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 5.1.1.导入pom坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Jackson依赖，不引入springmvc的情况下，设置序列化器需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;} 5.1.2 .配置文件 12345678910spring: redis: host: 192.168.150.101 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间} 5.1.3.测试代码 123456789101112131415@SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test void testString() &#123; // 写入一条String数据 redisTemplate.opsForValue().set(&quot;name&quot;, &quot;那个谁&quot;); // 获取string数据 Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125;&#125;} 提示：SpringDataRedis使用起来非常简单，记住如下几个步骤即可 SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis信息 注入RedisTemplate 5.2 .数据序列化器 RedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125;} 这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图： 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 5.3 StringRedisTemplate 尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图： 为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass RedisStringTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() &#123; // 写入一条String数据 stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125; private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException &#123; // 创建对象 User user = new User(&quot;虎哥&quot;, 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(&quot;user1 = &quot; + user1); &#125;&#125;} 此时再来看存储的数据，就会发现那个class数据已经不在了，节约了我们的空间。 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象","tags":["Redis"],"categories":["学习笔记"]},{"title":"友链","path":"/friends/index.html","content":"还没挂友链"},{"title":"关于本站","path":"/about/index.html","content":"尊敬的读者们： 欢迎来到我的个人博客。在创建网站的过程中，为丰富网站内容并提供多元化视角，作者在学习的过程中， 部分学习笔记等文章会整合互联网上各种优质资源，不限于 CSDN、OS China、掘金、Github等。 在此声明，一切文章仅为作者学习时笔记的整合和记录，无恶意搬运。 若有侵权，请立即联系作者删除。 如果您有任何疑问或者建议，欢迎您随时与我联系。邮箱：[3086660647@qq.com] 谢谢！ Echo"},{"title":"更多","path":"/more/index.html","content":"没有更多"}]