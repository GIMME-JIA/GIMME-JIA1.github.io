[{"title":"JVM-类的生命周期","path":"/2023/12/25/JVM-类的生命周期/","content":"生命周期概述 在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。 按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，完整生命周期包括如下 7 个阶段： 加载 Loading 连接 Linking 验证 准备 解析 初始化 Initization 使用 Using 卸载 Unloading 加载阶段 Loading 类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道，如：本地磁盘上的文件，程序运行时动态代理生成的类（Spring 的 IoC），使用早期的 Applet 技术进行网络传输的类。 类加载器在加载完类之后，Java 虚拟机会将字节码中的信息保存到方法区中。（方法区只是一个虚的概念） 在方法区中生成一个 InstanceKlass 对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。 Java 虚拟机还会在堆中生成一份与方法区中数据类似的 java.lang.Class 对象。作用是在 Java 代码中去获取类的信息，也就是反射的由来。里面会包含字段、方法等信息。 并且， 堆区的** java.lang.Class** 对象和方法区的InstanceKlass 对象之间会通过一个引用彼此关联。除此之外， jdk8 以后，堆区的 java.lang.Class 对象还会存放静态字段的数据。jdk8 之前存放在方法区。 思考题 问：为什么是创建两个对象而不是一个？ 答： 1、首先，方法区的InstanceKlass对象是通过 C++来编写的，Java 代码无法直接操作，所以 Java 虚拟机就在堆区创建了一个使用 Java 语言包装的 java.lang.Class 对象，可以在代码中获取到。 2、堆区的java.lang.Class 对象中的字段会少于方法区的InstanceKlass对象中的字段，比如虚方法表，这是 Java 虚拟机底层实现多态使用的，而对于开发者来说，只需要访问堆区中的** java.lang.Class** 对象而不需要访问方法区中所有的信息。也很好的控制开发者访问数据的范围。 查看内存中的对象 可以使用 JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar中。 启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB jps：展示所有的 java 进程号 连接阶段 Linking 1.验证 验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。 主要包含如下四部分，具体详见《Java虚拟机规范》： 文件格式验证，比如文件是否以0xCAFEBABE开头（即魔数是否正确），主次版本号是否满足当前Java虚拟机版本要求。 元信息验证，例如类必须有父类（super不能为空）。 验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。 符号引用验证，例如是否访问了其他类中private的方法等。 验证案例-版本号的检测 2.准备 一般情况 准备阶段会为静态变量（static）分配内存并设置初始值，而不会直接对静态变量赋值，而将 value 的值变成 1 会在初始化阶段完成。 各数据类型对应的初始值 如果不对静态变量设置初始值，那么在该内存可能会残留之前的无关数据，影响提高代码的可读性、可维护性，难以避免潜在的错误。 final 修饰 final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值，包括字符串。 注：本章涉及到的内存结构只讨论JDK8及之后的版本，8之前的版本后续章节详述。 3.解析 将常量池中的符号引用替换成指向内存的直接引用 符号引用就是在字节码文件中使用编号来访问常量池中的内容。 直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。 初始化阶段 Initialization 初始化阶段会执行静态代码块中的代码，并为静态变量赋值 初始化阶段会执行字节码文件中clinit部分的字节码指令 clinit：cl 表示 class ，init 表示初始化，即类的初始化 初始化案例分析 将代码两句 顺序颠倒 Snipaste_2023-12-23_13-03-02.png 由此可见，clinit方法中的执行顺序与Java中编写的顺序是一致的。 使类初始化的几种方式 访问一个类的静态变量或者静态方法的时候，会初始化这个类。 注：如果变量是 final 修饰的并且等号右边是常量不会触发初始化。如果赋值的内容需要执行指令才能得到结果，会执行 clinit 方法进行初始化。 调用 Class.forName(String className)。 注：Class.forName 是个重载方法，也可以指定不初始化。 指定 initialize 通过 new 关键字创建该对象。 执行 Main 方法的当前类。 **添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类 ** clinit 指定不会出现的情况 无静态代码块且无静态变量赋值语句。 有静态变量声明，但没有赋值语句。 静态变量的定义使用 final 关键字，这类变量会在准备阶段进行初始化。 初始化试题 求运行结果 **new的执行顺序：实例代码块-&gt;构造函数。**初始化只会加载静态区中的数据，且静态区数据只会加载一次，所以是DACBCB。 求运行结果 结果：答案为 2，子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。 将 new B02()去掉，结果会怎么样？ 结果：答案为 1，直接访问父类的静态变量，不会触发子类的初始化。 求运行结果 12345678910public class Demo &#123; public static void main(String[] args) &#123; Demo2[] a = new Demo2[10]; &#125;&#125;class Demo2&#123; static &#123; System.out.println(&quot;静态代码块run&quot;); &#125;&#125; 结果：答案是控制台为空，因为数组的创建不会导致数组元素的类进行初始化 求运行结果 123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Demo2.a); &#125;&#125;class Demo2&#123; public static final int a = Integer.valueOf(1); static &#123; System.out.println(&quot;静态代码块run&quot;); &#125;&#125;// 控制台：// 静态代码块run// 1 结果：final 修饰的变量如果赋值的内容需要执行指令才能得到结果，会执行 clinit 方法进行初始化。 使用阶段 Using 不做赘述 卸载阶段 Unloading","tags":["JVM"],"categories":["学习笔记"]},{"title":"JVM-字节码文件","path":"/2023/12/24/JVM-字节码文件/","content":"字节码文件的组成 基本信息 包含了字节码文件的版本信息和其他一些元数据。字节码文件头部的魔数（ca fe ba be）用于告诉Java虚拟机，这个文件是一个合法的Java类文件，它可能会包含一些其他的元数据，例如编译器版本信息（JDK版本 = 主版本号 - 44），字节码文件的编译日期、父类和接口等。 常量池 包含了程序中使用到的各种常量，这些常量包括数字、字符串、类名、方法名等等。Java虚拟机在运行时需要用到常量池，因为Java虚拟机中的很多指令操作都需要用到常量池中的一些值。 字段 描述了一个类中的所有字段。字段包括其类型、名称和访问标志。在Java中，所有类中都有构造器和至少一个初始化方法（主方法）。 方法 描述了一个类中的所有方法。方法包括其名称、参数类型和返回类型，同时也包括方法的字节码指令和异常处理信息。通过这些方法，Java虚拟机能够理解程序中要执行的代码逻辑。 属性 这一部分用于保存一些额外的元数据，例如Java中的注解信息等。 接口 描述了所有实现或继承的接口。接口是Java中一种很重要的方式，用于描述要实现或者继承的共同特征和行为。它们允许Java程序员通过一个类继承和实现多种类型，从而获得最大程度的复用和可扩展性。 字节码常用工具 阿里 Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。 官网：https://arthas.aliyun.com/doc/ dump 类的全限定名：dump已加载类的字节码文件到特定目录。 jad 类的全限定名： 反编译已加载类的源码。 启动 Arthas： java -jar arthas-boot.jar jclasslib 既有 pc 端 app，也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码文件内容。 Github地址： https://github.com/ingokegel/jclasslib javap -v 命令 javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件容。 直接输入javap查看所有参数。 输入javap -v 字节码文件名称 查看具体的字节码息。（如果jar包需要先使用 jar –xvf 命令解压） 阅读字节码文件 ”显示 jvm 规范“看查看每条字节码指令所表示含义 字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。","tags":["JVM"],"categories":["学习笔记"]},{"title":"数据结构—递归","path":"/2023/12/11/数据结构-递归/","content":"1) 概述 定义 计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集 In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. 说明： 自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的） 每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归 内层函数调用（子集处理）完成，外层函数才能算调用完成 思路 确定能否使用递归求解 推导出递推关系，即父问题与子问题的关系，以及递归的结束条件 深入到最里层叫做递 从最里层出来叫做归 在递的过程中，外层函数内的局部变量（以及方法参数）并未消失，归的时候还可以用到 2) 单路递归 Single Recursion E01. 阶乘 用递归方法求阶乘 阶乘的定义 n!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅nn!= 1⋅2⋅3⋯(n-2)⋅(n-1)⋅nn!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅n，其中 nnn 为自然数，当然 0!=10! = 10!=1 递推关系 f(n)={1n=1n∗f(n−1)n&gt;1f(n) = \\begin{cases} 1 &amp; n = 1\\\\ n * f(n-1) &amp; n &gt; 1 \\end{cases} f(n)={1n∗f(n−1)​n=1n&gt;1​ 代码 123456private static int f(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * f(n - 1);&#125; E02. 反向打印字符串 用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置 递：n 从 0 开始，每次 n + 1，一直递到 n == str.length() - 1 归：从 n == str.length() 开始归，从归打印，自然是逆序的 递推关系 f(n)={停止n=str.length()f(n+1)0≤n≤str.length()−1f(n) = \\begin{cases} 停止 &amp; n = str.length() \\\\ f(n+1) &amp; 0 \\leq n \\leq str.length() - 1 \\end{cases} f(n)={停止f(n+1)​n=str.length()0≤n≤str.length()−1​ 代码为 1234567public static void reversePrint(String str, int index) &#123; if (index == str.length()) &#123; return; &#125; reversePrint(str, index + 1); System.out.println(str.charAt(index));&#125; E03. 二分查找（单路递归） 1234567891011121314151617public static int binarySearch(int[] a, int target) &#123; return recursion(a, target, 0, a.length - 1);&#125;public static int recursion(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return recursion(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return recursion(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; E04. 冒泡排序（单路递归） 12345678910111213141516171819202122232425public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 4, 7&#125;; bubble(a, 0, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void bubble(int[] a, int low, int high) &#123; if(low == high) &#123; return; &#125; int j = low; for (int i = low; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); j = i; // j将指向右边最大的元素，即右边界 &#125; &#125; bubble(a, low, j);&#125;private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125; low 与 high 为未排序范围 j 表示的是未排序的边界，下一次递归时的 high 发生交换，意味着有无序情况 最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1 已然有序 E05. 插入排序（单路递归） 123456789101112131415161718192021public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 7, 4&#125;; insertion(a, 1, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void insertion(int[] a, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low - 1; int t = a[low]; while (i &gt;= 0 &amp;&amp; a[i] &gt; i) &#123; a[i + 1] = a[i]; i--; &#125; if(i + 1 != low) &#123; a[i + 1] = t; &#125; insertion(a, low + 1, high);&#125; 已排序区域：[0 … i … low-1] 未排序区域：[low … high] E06. 约瑟夫问题（单路递归） nnn 个人排成圆圈，从头开始报数，每次数到第 mmm 个人（mmm 从 111 开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？ 方法1 根据最后的存活者 a 倒推出它在上一轮的索引号 f(n,m) 本轮索引 为了让 a 是这个索引，上一轮应当这样排 规律 f(1,3) 0 x x x a (0 + 3) % 2 f(2,3) 1 x x x 0 a (1 + 3) % 3 f(3,3) 1 x x x 0 a (1 + 3) % 4 f(4,3) 0 x x x a (0 + 3) % 5 f(5,3) 3 x x x 0 1 2 a (3 + 3) % 6 f(6,3) 0 x x x a 方法2 设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始 f(n, m) 解 规律 f(1, 3) 0 f(2, 3) 0 1 =&gt; 1 3%2=1 f(3, 3) 0 1 2 =&gt; 0 1 3%3=0 f(4, 3) 0 1 2 3 =&gt; 3 0 1 3%4=3 f(5, 3) 0 1 2 3 4 =&gt; 3 4 0 1 3%5=3 f(6, 3) 0 1 2 3 4 5 =&gt; 3 4 5 0 1 3%6=3 一. 找出等价函数 规律：下次报数的起点为 k=m%nk = m \\% nk=m%n 首次出列人的序号是 k−1k-1k−1，剩下的的 n−1n-1n−1 个人重新组成约瑟夫环 下次从 kkk 开始数，序号如下 k, k+1, ... , 0, 1, k−2k,\\ k+1, \\ ...\\ ,\\ 0,\\ 1,\\ k-2k, k+1, ... , 0, 1, k−2，如上例中 3 4 5 0 13\\ 4\\ 5\\ 0\\ 13 4 5 0 1 这个函数称之为 g(n−1,m)g(n-1,m)g(n−1,m)，它的最终结果与 f(n,m)f(n,m)f(n,m) 是相同的。 二. 找到映射函数 现在想办法找到 g(n−1,m)g(n-1,m)g(n−1,m) 与 f(n−1,m)f(n-1, m)f(n−1,m) 的对应关系，即 3→04→15→20→31→43 \\rightarrow 0 \\\\ 4 \\rightarrow 1 \\\\ 5 \\rightarrow 2 \\\\ 0 \\rightarrow 3 \\\\ 1 \\rightarrow 4 \\\\ 3→04→15→20→31→4 映射函数为 mapping(x)={x−kx=[k..n−1]x+n−kx=[0..k−2]mapping(x) = \\begin{cases} x-k &amp; x=[k..n-1] \\\\ x+n-k &amp; x=[0..k-2] \\end{cases} mapping(x)={x−kx+n−k​x=[k..n−1]x=[0..k−2]​ 等价于下面函数 mapping(x)=(x+n−k)%nmapping(x) = (x + n - k)\\%{n} mapping(x)=(x+n−k)%n 代入测试一下 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→43 \\rightarrow (3+6-3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+6-3)\\%6 \\rightarrow 1 \\\\ 5 \\rightarrow (5+6-3)\\%6 \\rightarrow 2 \\\\ 0 \\rightarrow (0+6-3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+6-3)\\%6 \\rightarrow 4 \\\\ 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→4 综上有 f(n−1,m)=mapping(g(n−1,m))f(n-1,m) = mapping(g(n-1,m)) f(n−1,m)=mapping(g(n−1,m)) 三. 求逆映射函数 映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x mapping−1(x)=(x+k)%nmapping^{-1}(x) = (x + k)\\%n mapping−1(x)=(x+k)%n 代入测试一下 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→10 \\rightarrow (0+3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+3)\\%6 \\rightarrow 4 \\\\ 2 \\rightarrow (2+3)\\%6 \\rightarrow 5 \\\\ 3 \\rightarrow (3+3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+3)\\%6 \\rightarrow 1 \\\\ 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→1 因此可以求得 g(n−1,m)=mapping−1(f(n−1,m))g(n-1,m) = mapping^{-1}(f(n-1,m)) g(n−1,m)=mapping−1(f(n−1,m)) 四. 递推式 代入推导 f(n,m)= g(n−1,m)= mapping−1(f(n−1,m))= (f(n−1,m)+k)%n= (f(n−1,m)+m%n)%n= (f(n−1,m)+m)%n\\begin{aligned} f(n,m) = \\ &amp; g(n-1,m) \\\\ = \\ &amp; mapping^{-1}(f(n-1,m)) \\\\ = \\ &amp; (f(n-1,m) + k) \\% n \\\\ = \\ &amp; (f(n-1,m) + m\\%n) \\% n \\\\ = \\ &amp; (f(n-1,m) + m) \\% n \\\\ \\end{aligned} f(n,m)= = = = = ​g(n−1,m)mapping−1(f(n−1,m))(f(n−1,m)+k)%n(f(n−1,m)+m%n)%n(f(n−1,m)+m)%n​ 最后一步化简是利用了模运算法则 (a+b)%n=(a%n+b%n)%n(a+b)\\%n = (a\\%n + b\\%n) \\%n(a+b)%n=(a%n+b%n)%n 例如 (6+6)%5=2=(6+6%5)%5(6+6)\\%5 = 2 = (6+6\\%5)\\%5(6+6)%5=2=(6+6%5)%5 (6+5)%5=1=(6+5%5)%5(6+5)\\%5 = 1 = (6+5\\%5)\\%5(6+5)%5=1=(6+5%5)%5 (6+4)%5=0=(6+4%5)%5(6+4)\\%5 = 0 = (6+4\\%5)\\%5(6+4)%5=0=(6+4%5)%5 最终递推式 f(n,m)={(f(n−1,m)+m)%nn&gt;10n=1f(n,m) = \\begin{cases} (f(n-1,m) + m) \\% n &amp; n&gt;1\\\\ 0 &amp; n = 1 \\end{cases} f(n,m)={(f(n−1,m)+m)%n0​n&gt;1n=1​ 3) 多路递归 Multi Recursion E01. 斐波那契数列 之前的例子是每个递归函数只包含一个自身的调用，这称之为 single recursion 如果每个递归函数例包含多个自身调用，称之为 multi recursion 递推关系 f(n)={0n=01n=1f(n−1)+f(n−2)n&gt;1f(n) = \\begin{cases} 0 &amp; n=0 \\\\ 1 &amp; n=1 \\\\ f(n-1) + f(n-2) &amp; n&gt;1 \\end{cases} f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n&gt;1​ 下面的表格列出了数列的前几项 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 0 1 1 2 3 5 8 13 21 34 55 89 144 233 实现 123456789public static int f(int n) &#123; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; return f(n - 1) + f(n - 2);&#125; 执行流程 绿色代表正在执行（对应递），灰色代表执行结束（对应归） 递不到头，不能归，对应着深度优先搜索 时间复杂度 递归的次数也符合斐波那契规律，2∗f(n+1)−12 * f(n+1)-12∗f(n+1)−1 时间复杂度推导过程 斐波那契通项公式 f(n)=15∗(1+52n−1−52n)f(n) = \\frac{1}{\\sqrt{5}}*({\\frac{1+\\sqrt{5}}{2}}^n - {\\frac{1-\\sqrt{5}}{2}}^n)f(n)=5​1​∗(21+5​​n−21−5​​n) 简化为：f(n)=12.236∗(1.618n−(−0.618)n)f(n) = \\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)f(n)=2.2361​∗(1.618n−(−0.618)n) 带入递归次数公式 2∗12.236∗(1.618n+1−(−0.618)n+1)−12*\\frac{1}{2.236}*({1.618}^{n+1} - {(-0.618)}^{n+1})-12∗2.2361​∗(1.618n+1−(−0.618)n+1)−1 时间复杂度为 Θ(1.618n)\\Theta(1.618^n)Θ(1.618n) 更多 Fibonacci 参考[8][9][^10] 以上时间复杂度分析，未考虑大数相加的因素 变体1 - 兔子问题 第一个月，有一对未成熟的兔子（黑色，注意图中个头较小） 第二个月，它们成熟 第三个月，它们能产下一对新的小兔子（蓝色） 所有兔子遵循相同规律，求第 nnn 个月的兔子数 分析 兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 f(n)f(n)f(n) f(n)f(n)f(n) = 上个月兔子数 + 新生的小兔子数 而【新生的小兔子数】实际就是【上个月成熟的兔子数】 因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】 上个月兔子数，即 f(n−1)f(n-1)f(n−1) 上上个月的兔子数，即 f(n−2)f(n-2)f(n−2) 因此本质还是斐波那契数列，只是从其第一项开始 变体2 - 青蛙爬楼梯 楼梯有 nnn 阶 青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶 只能向上跳，问有多少种跳法 分析 n 跳法 规律 1 (1) 暂时看不出 2 (1,1) (2) 暂时看不出 3 (1,1,1) (1,2) (2,1) 暂时看不出 4 (1,1,1,1) (1,2,1) (2,1,1)(1,1,2) (2,2) 最后一跳，跳一个台阶的，基于f(3)最后一跳，跳两个台阶的，基于f(2) 5 … … 因此本质上还是斐波那契数列，只是从其第二项开始 E02. 汉诺塔（多路递归） Tower of Hanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着 64 片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定 一次只能移动一个圆盘 小圆盘上不能放大圆盘 下面的动图演示了4片圆盘的移动方法 E03. 杨辉三角 优化1 在multiple recursion过程中，有很多 ，因此很多递归调用是重复的，用 memoization 来进行优化： 123456789101112131415161718192021222324public static void print1(int n) &#123; int[][] triangle = new int[n][]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 triangle[i] = new int[i + 1]; for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, element1(triangle, i, j)); &#125; System.out.println(); &#125;&#125;public static int element1(int[][] triangle, int i, int j) &#123; if (triangle[i][j] &gt; 0) &#123; return triangle[i][j]; &#125; if (j == 0 || i == j) &#123; triangle[i][j] = 1; return triangle[i][j]; &#125; triangle[i][j] = element1(triangle, i - 1, j - 1) + element1(triangle, i - 1, j); return triangle[i][j];&#125; 将数组作为递归函数内可以访问的遍历，如果 triangle[i][j]triangle[i][j]triangle[i][j] 已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了 优化2 123456789101112131415161718192021public static void print2(int n) &#123; int[] row = new int[n]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 createRow(row, i); for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, row[j]); &#125; System.out.println(); &#125;&#125;private static void createRow(int[] row, int i) &#123; if (i == 0) &#123; row[0] = 1; return; &#125; for (int j = i; j &gt; 0; j--) &#123; row[j] = row[j - 1] + row[j]; &#125;&#125; 4) 递归优化-记忆法 Memoization 记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码 1234567891011121314151617public static void main(String[] args) &#123; int n = 13; int[] cache = new int[n + 1]; Arrays.fill(cache, -1); cache[0] = 0; cache[1] = 1; System.out.println(f(cache, n));&#125;public static int f(int[] cache, int n) &#123; if (cache[n] != -1) &#123; return cache[n]; &#125; cache[n] = f(cache, n - 1) + f(cache, n - 2); return cache[n];&#125; 优化后的图示，只要结果被缓存，就不会执行其子问题 改进后的时间复杂度为 O(n)O(n)O(n) 注意 记忆法是动态规划的一种情况，强调的是自顶向下的解决 记忆法的本质是空间换时间 5) 递归优化-尾递归 爆栈 每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等 方法调用占用的内存需要等到方法结束时才会释放 而递归调用过程中，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了 尾调用 如果函数的最后一步是调用一个函数，那么称为尾调用 尾递归 尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数 尾递归避免爆栈 Java目前还不支持，但可以在IDEA插件安装 Scala 12345object Main &#123; def main(args: Array[String]): Unit = &#123; println(&quot;Hello Scala&quot;) &#125;&#125; Scala中，java 中的类都可以拿来重用 类型是放在变量后面的 Unit 表示无返回值，类似于 void 不需要以分号作为结尾，当然加上也对 Scala 最后一行代码若作为返回值，可以省略 return 代码如下 1234567@tailrecdef sum(n: Long, accumulator: Long): Long = &#123; if (n == 1) &#123; return 1 + accumulator &#125; return sum(n - 1, n + accumulator)&#125; accumulator 作为累加器 @tailrec 注解是 scala 提供的，用来检查方法是否符合尾递归 本质上，尾递归优化是将函数的递归调用，变成了函数的循环调用，可以在java中改为循坏避免爆栈问题 6) 递归时间复杂度-Master theorem 若有递归式 T(n)=aT(nb)+f(n)T(n) = aT(\\frac{n}{b}) + f(n) T(n)=aT(bn​)+f(n) 其中 T(n)T(n)T(n) 是问题的运行时间，nnn 是数据规模 aaa 是子问题个数 T(nb)T(\\frac{n}{b})T(bn​) 是子问题运行时间，每个子问题被拆成原问题数据规模的 nb\\frac{n}{b}bn​ f(n)f(n)f(n) 是除递归外执行的计算 令 x=log⁡bax = \\log_{b}{a}x=logb​a，即 x=log⁡子问题缩小倍数子问题个数x = \\log_{子问题缩小倍数}{子问题个数}x=log子问题缩小倍数​子问题个数 那么 T(n)={Θ(nx)f(n)=O(nc)并且c&lt;xΘ(nxlog⁡n)f(n)=Θ(nx)Θ(nc)f(n)=Ω(nc)并且c&gt;xT(n) = \\begin{cases} \\Theta(n^x) &amp; f(n) = O(n^c) 并且 c \\lt x\\\\ \\Theta(n^x\\log{n}) &amp; f(n) = \\Theta(n^x)\\\\ \\Theta(n^c) &amp; f(n) = \\Omega(n^c) 并且 c \\gt x \\end{cases} T(n)=⎩⎨⎧​Θ(nx)Θ(nxlogn)Θ(nc)​f(n)=O(nc)并且c&lt;xf(n)=Θ(nx)f(n)=Ω(nc)并且c&gt;x​ 例1 T(n)=2T(n2)+n4T(n) = 2T(\\frac{n}{2}) + n^4T(n)=2T(2n​)+n4 此时 x=1&lt;4x = 1 &lt; 4x=1&lt;4，由后者决定整个时间复杂度 Θ(n4)\\Theta(n^4)Θ(n4) 如果觉得对数不好算，可以换为求【bbb 的几次方能等于 aaa】 例2 T(n)=T(7n10)+nT(n) = T(\\frac{7n}{10}) + nT(n)=T(107n​)+n a=1,b=107,x=0,c=1a=1, b=\\frac{10}{7}, x=0, c=1a=1,b=710​,x=0,c=1 此时 x=0&lt;1x = 0 &lt; 1x=0&lt;1，由后者决定整个时间复杂度 Θ(n)\\Theta(n)Θ(n) 例3 T(n)=16T(n4)+n2T(n) = 16T(\\frac{n}{4}) + n^2T(n)=16T(4n​)+n2 a=16,b=4,x=2,c=2a=16, b=4, x=2, c=2a=16,b=4,x=2,c=2 此时 x=2=cx=2 = cx=2=c，时间复杂度 Θ(n2log⁡n)\\Theta(n^2 \\log{n})Θ(n2logn) 例4 T(n)=7T(n3)+n2T(n)=7T(\\frac{n}{3}) + n^2T(n)=7T(3n​)+n2 a=7,b=3,x=1.?,c=2a=7, b=3, x=1.?, c=2a=7,b=3,x=1.?,c=2 此时 x=log⁡37&lt;2x = \\log_{3}{7} &lt; 2x=log3​7&lt;2，由后者决定整个时间复杂度 Θ(n2)\\Theta(n^2)Θ(n2) 例5 T(n)=7T(n2)+n2T(n) = 7T(\\frac{n}{2}) + n^2T(n)=7T(2n​)+n2 a=7,b=2,x=2.?,c=2a=7, b=2, x=2.?, c=2a=7,b=2,x=2.?,c=2 此时 x=log27&gt;2x = log_2{7} &gt; 2x=log2​7&gt;2，由前者决定整个时间复杂度 Θ(nlog⁡27)\\Theta(n^{\\log_2{7}})Θ(nlog2​7) 例6 T(n)=2T(n4)+nT(n) = 2T(\\frac{n}{4}) + \\sqrt{n}T(n)=2T(4n​)+n​ a=2,b=4,x=0.5,c=0.5a=2, b=4, x = 0.5, c=0.5a=2,b=4,x=0.5,c=0.5 此时 x=0.5=cx = 0.5 = cx=0.5=c，时间复杂度 Θ(nlog⁡n)\\Theta(\\sqrt{n}\\log{n})Θ(n​logn) 7) 递归时间复杂度-展开求解 像下面的递归式，都不能用主定理求解 例1 - 递归求和 123456long sum(long n) &#123; if (n == 1) &#123; return 1; &#125; return n + sum(n - 1);&#125; T(n)=T(n−1)+cT(n) = T(n-1) + cT(n)=T(n−1)+c，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+c+cT(n) = T(n-2) + c + cT(n)=T(n−2)+c+c T(n)=T(n−3)+c+c+cT(n) = T(n-3) + c + c + cT(n)=T(n−3)+c+c+c … T(n)=T(n−(n−1))+(n−1)cT(n) = T(n-(n-1)) + (n-1)cT(n)=T(n−(n−1))+(n−1)c 其中 T(n−(n−1))T(n-(n-1))T(n−(n−1)) 即 T(1)T(1)T(1) 带入求得 T(n)=c+(n−1)c=ncT(n) = c + (n-1)c = ncT(n)=c+(n−1)c=nc 时间复杂度为 O(n)O(n)O(n) 例2 - 递归冒泡排序 1234567891011void bubble(int[] a, int high) &#123; if(0 == high) &#123; return; &#125; for (int i = 0; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); &#125; &#125; bubble(a, high - 1);&#125; T(n)=T(n−1)+nT(n) = T(n-1) + nT(n)=T(n−1)+n，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+(n−1)+nT(n) = T(n-2) + (n-1) + nT(n)=T(n−2)+(n−1)+n T(n)=T(n−3)+(n−2)+(n−1)+nT(n) = T(n-3) + (n-2) + (n-1) + nT(n)=T(n−3)+(n−2)+(n−1)+n … T(n)=T(1)+2+...+n=T(1)+(n−1)2+n2=c+n22+n2−1T(n) = T(1) + 2 + ... + n = T(1) + (n-1)\\frac{2+n}{2} = c + \\frac{n^2}{2} + \\frac{n}{2} -1T(n)=T(1)+2+...+n=T(1)+(n−1)22+n​=c+2n2​+2n​−1 时间复杂度 O(n2)O(n^2)O(n2) 注： 等差数列求和为 个数∗∣首项−末项∣2个数*\\frac{\\vert首项-末项\\vert}{2}个数∗2∣首项−末项∣​ 可用该站进行公式推导：https://www.wolframalpha.com/","tags":["数据结构"],"categories":["学习笔记"]},{"title":"b","path":"/2023/11/24/b/","content":"还行 不是 啊 这 不是吧 哦哦"},{"title":"a","path":"/2023/11/23/a/","content":"我是一只小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的","tags":["Java"],"categories":["技术随笔"]},{"title":"Redis-基础","path":"/2023/11/08/Redis-基础/","content":"1.Redis简单介绍 Redis是一种键值型的NoSql数据库，这里有两个关键字： 键值型 NoSql 其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json。 而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。 对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。 2.初识Redis 2.1.认识NoSQL NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 2.1.1.结构化与非结构化 传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。 而NoSql则对数据库格式没有严格约束，往往形式松散，自由。 可以是键值型，也可以是文档型，甚至可以是图格式。 2.1.2.关联和非关联 传统数据库的表与表之间往往存在关联，例如外键： 而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合： 123456789101112131415161718&#123; id: 1, name: &quot;张三&quot;, orders: [ &#123; id: 1, item: &#123; id: 10, title: &quot;荣耀6&quot;, price: 4999 &#125; &#125;, &#123; id: 2, item: &#123; id: 20, title: &quot;小米11&quot;, price: 3999 &#125; &#125; ]&#125; 此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。 2.1.3.查询方式 传统关系型数据库会基于Sql语句做查询，语法有统一标准； 而不同的非关系数据库查询语法差异极大，五花八门各种各样。 2.1.4.事务 传统关系型数据库能满足事务ACID的原则。 而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。 2.1.5.总结 除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下： 存储方式 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些 扩展性 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦 2.2.认识Redis Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存.IO多路复用.良好的编码）。 支持数据持久化 支持主从集群.分片集群 支持多语言客户端 Redis的官方网站地址：https://redis.io/ 3.Redis常见命令 3.1 Redis数据结构介绍 Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令，也可以执行该命令进入容器执行命令。 1docker exec -it &lt;container_name_or_id&gt; redis-cli 3.2 Redis 通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL(Time To Live，生存时间)：查看一个KEY的剩余有效期 通过help [command] 可以查看一个命令的具体用法。 代码如下 KEYS 123456789127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt; 提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 DEL 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1 #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;\t#只剩下一个了127.0.0.1:6379&gt; 提示：在拷贝代码的时候，只需要拷贝对应的命令 EXISTS 123456789101112127.0.0.1:6379&gt; help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE 提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除 1234567891011127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1 # ttl的返回值就是-1 3.3 Redis命令-String命令 String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 String的常见命令有： SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（必须指定增长步长） SETNX(set not exit)：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX(set key expire time)：添加一个String类型的键值对，并且指定有效期 提示：以上命令除了INCRBYFLOAT 都是常用命令，且有一些组合命令如SETNX,SETEX. SET 和GET: 如果key不存在则是新增，如果存在则是修改 1234567891011127.0.0.1:6379&gt; set name Rose //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot; MSET和MGET 123456789127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot; //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot; INCR和INCRBY和DECY 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11 127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值 127.0.0.1:6379&gt; incrby age 2(integer) 15 127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14 127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12 127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11 127.0.0.1:6379&gt; get age &quot;11&quot; SETNX 1234567891011121314151617127.0.0.1:6379&gt; help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string127.0.0.1:6379&gt; set name Jack //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot; SETEX 12345678127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7 3.4 Redis命令-Key的层级结构 Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:'隔开，格式如下： **项目名：业务名：类型：id** 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于文件夹的结构，更加方便Redis获取数据。 3.5 Redis命令-Hash命令 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。 Hash类型的常见命令 HSET key field value：添加或者修改hash类型key的field的值 HGET key field：获取一个hash类型key的field的值 HMSET：批量获取多个hash类型key的field的值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有的field HVALS：获取一个hash类型的key中的所有的field的值 HINCRBY:让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 提示：哈希结构也是实际开发中常用的命令 HSET和HGET 12345678910127.0.0.1:6379&gt; HSET user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET user:3 age&quot;17&quot; HMSET和HMGET 12345678127.0.0.1:6379&gt; HMSET user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HGETALL 1234567127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot; HKEYS和HVALS 12345678127.0.0.1:6379&gt; HKEYS user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HINCRBY 12345678127.0.0.1:6379&gt; HINCRBY user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY user:4 age -2(integer) 20 HSETNX 12345678910111213141516127.0.0.1:6379&gt; HSETNX user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot; 3.6 Redis命令-List命令 Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element … ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素，start表示起始索引，end表示结束索引 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil LPUSH和RPUSH 1234127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6 LPOP和RPOP 1234127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot; LRANGE 123127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot; 3.7 Redis命令-Set命令 Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set类型的常见命令 SADD key member … ：向set中添加一个或多个元素 SREM key member … : 移除set中的指定元素 SCARD key： 返回set中元素的个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2 … ：求key1与key2的交集 SDIFF key1 key2 … ：求key1与key2的差集 SUNION key1 key2 …：求key1和key2的并集 例如两个集合：s1和s2: 求交集：SINTER s1 s2 求s1与s2的不同：SDIFF s1 s2 具体命令 1234567891011121314151617127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1 127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0 127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1 127.0.0.1:6379&gt; SCARD s1(integer) 2 3.8 Redis命令-SortedSet类型 Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member : 获取sorted set中的指定元素的score值 ZRANK key member：获取sorted set 中的指定元素的排名 ZCARD key：获取sorted set中的元素个数 ZCOUNT key min max：统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max：按照score排序后，获取指定排名范围内的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF.ZINTER.ZUNION：求差集.交集.并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 4.Redis的Java客户端-Jedis 在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。 4.1 Jedis快速入门 入门案例详细步骤 案例分析： 0）创建工程： 1）引入依赖： 12345678910111213&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）建立连接 新建一个单元测试类，内容如下： 123456789101112private Jedis jedis;@BeforeEachvoid setUp() &#123; // 1.建立连接 // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(&quot;123321&quot;); // 3.选择库 jedis.select(0);&#125; 3）测试： 1234567891011121314151617181920@Testvoid testString() &#123; // 存入数据 String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123; // 插入hash数据 jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;); jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;); // 获取 Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;); System.out.println(map);&#125;} 4）释放资源 123456@AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125;} 4.2 Jedis连接池 Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如tomcat中的线程池，这些都是池化思想的体现。 4.2.1.创建Jedis的连接池 1234567891011121314151617181920public class JedisConnectionFacotry &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;} 代码说明： 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，可以使用工厂，去降低耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3）最后提供返回连接池中连接的方法. 4.2.2.改造原始代码 代码说明: 1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。 ，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。 2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。 123456789101112131415 @BeforeEach void setUp()&#123; //建立连接 /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); &#125;@AfterEach void tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;} 5.Redis的Java客户端-SpringDataRedis SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 5.1.快速入门 SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 5.1.1.导入pom坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Jackson依赖，不引入springmvc的情况下，设置序列化器需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;} 5.1.2 .配置文件 12345678910spring: redis: host: 192.168.150.101 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间} 5.1.3.测试代码 123456789101112131415@SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test void testString() &#123; // 写入一条String数据 redisTemplate.opsForValue().set(&quot;name&quot;, &quot;那个谁&quot;); // 获取string数据 Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125;&#125;} 提示：SpringDataRedis使用起来非常简单，记住如下几个步骤即可 SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis信息 注入RedisTemplate 5.2 .数据序列化器 RedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125;} 这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图： 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 5.3 StringRedisTemplate 尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图： 为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass RedisStringTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() &#123; // 写入一条String数据 stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125; private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException &#123; // 创建对象 User user = new User(&quot;虎哥&quot;, 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(&quot;user1 = &quot; + user1); &#125;&#125;} 此时再来看存储的数据，就会发现那个class数据已经不在了，节约了我们的空间。 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象","tags":["Redis"],"categories":["学习笔记"]},{"title":"MySQL-基础(2)","path":"/2023/05/25/MySQL-基础(2)/","content":"函数 概念 函数一般是指一段可以直接被另一段程序调用的程序或代码 字符串函数 MySQL常用函数如下： 函数 功能 CONCAT(S1,S2,…Sn) 字符串拼接，将S1,S2,…Sn拼成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str，n，pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str，n，pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str，strart，len) 返回从字符串str从start位置起的len个长度的字符串 123456789101112SELECT CONCAT(&#x27;hello&#x27;,&#x27;masql&#x27;,&#x27;!&#x27;); # hellomasql!SELECT UPPER(&#x27;hleeo&#x27;); # HLEEOSELECT LOWER(&#x27;HELLO&#x27;); # helloSELECT LPAD(&#x27;HELLO&#x27;,9,&#x27;--&#x27;); # ----HELLOSELECT RPAD(&#x27;HELLO&#x27;,9,&#x27;--&#x27;); # HELLO----SELECT TRIM(&#x27; hello world &#x27;); # hello worldSELECT SUBSTRING(&#x27; hello world &#x27;,1,10); 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(X) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 12345678910111213141516-- 数值函数SELECT RAND(); SELECT MOD(5,2); # 1SELECT ROUND(3.1415926,5); # 3.14159SELECT CEIL(1.000001);\t# 2SELECT FLOOR(1.9999999); # 1-- 通过函数，生成一个六位数的随机验证码-- 先生成一个随机数乘以1000000-- 再对其进行四舍五入保留0位小数-- 最后将其进行填充，以达到六位数SELECT LPAD(ROUND(RAND() * 1000000,0),6,&#x27;0&#x27;); 日期函数 常见日期函数如下 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date，INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1，date2) 返回起始时间data1和结束时间date2之间的天数 123456789101112131415161718-- 时间函数SELECT CURDATE(); -- 2023-03-23SELECT CURTIME(); -- 21:34:42SELECT NOW(); -- 2023-03-23 21:34:17SELECT YEAR(NOW()); -- 2023SELECT MONTH(NOW()); -- 3SELECT DAY(NOW()); -- 23SELECT DATE_ADD(NOW(),INTERVAL 70 YEAR); -- 2093-03-23 21:37:21-- 前面的时间减去后面的时间SELECT DATEDIFF(CURDATE(),&#x27;2003-12-27&#x27;); -- 7026SELECT DATEDIFF(&#x27;2003-12-27&#x27;,CURDATE()); -- -7026 流程控制函数 流程函数也是常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句效率 函数 功能 IF(value，t，f) 如果value为true，则返回t，否则返回f IFNULL(value1，value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [val1] THEN [res1] …ELSE [default] END 如果val1为true，返回rest1，…否则返回fedault默认值 CASE [expr] WHEN [val1] THEN [res1] …ELSE [default] END 如果expr的值等于val1，返回res1，…否则返回default默认值 字段演示 表达式演示 约束 概念 约束是作用于表中列上得规则，用于限制加入表的数据； 约束的存在保证了数据库中数据的正确性、有效性和完整性。 约束的分类 名称 描述 关键字 非空约束 保证所有数据不为null NUT NULL 唯一约束 保证列中所有数据各不相同 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 检查约束 保证列中所有的值满足某一条件 CHECK 默认约束 保存数据时，未指定值则采用默认值 DEFAULT 外键约束 外键用来让两个表的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 额外的，主键自动增长：AUTO_INCREMENT（使用条件：当前列是数字类型并且唯一约束） 代码演示 12345678CREATE TABLE person(id INT PRIMARY KEY AUTO_INCREMENT, -- id，主键且自增长name VARCHAR(20) NOT NULL UNIQUE, -- 姓名，非空且唯一age INT CHECK(age &lt;100 AND age &gt; 0), -- 年龄，大于0小于100sex VARCHAR(5) NOT NULL , -- 性别，不为空address VARCHAR(5) NOT NULL, -- 住址，不为空score DOUBLE(5,2) DEFAULT 0 NOT NULL -- 成绩默认为0,不为空); 外键约束 语法 外键的创建，需要满足以下四个条件，否则会被MySQL数据库拒绝： 1、创建外键的表和列存在 2、组成外键的列存在索引 3、外键字段和关联字段，数据类型必须一致 删除/更新行为 行为 说明 NO ACTION （默认行为） 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致) RESTRICT（默认行为） 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致) CASCADE 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 SET NULL 当在父表中删除对应记录时，首先应该检查是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许null)。 SET DEFAULT 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)。 12-- CASCADEALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY 从表字段名 REFERANCE 主表(字段名) ON UPDATE 行为 ON DELETE 行为; 添加约束 123456789-- 创建表时添加外键约束CREATE TABLE 表名(\t列名 数据类型, …… [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名));-- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表(主表列名); 删除约束 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 实例演示 1234567891011121314151617181920-- 部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT,\tdep_name varchar(10));-- 员工表CREATE TABLE emp( id INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(10),\tage int,\tdep_id int, -- 添加外键 dep-id,关联dept表的id主键\tCONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id));-- 注：当需要添加外键时，应该先有主表再有从表，信息的添加也是。-- 创建完表后添加外键ALTER TABLE emp ADD CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id); 逆向表到模型演示 12-- 删除外键ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept; 逆向表到模型演示 多表查询 简介 笛卡尔积：取A,B组合所有情况 多表查询：从多张表查询数据 多表关系介绍 一对一 - 如 用户 与 用户详情 的关系 - 一对一对用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 - 在任意一方面加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE 一对多 - 如 部门 与 员工 的关系 - 个部门对应多个员工，一个员工对应一个部门 - 在多的一方建立外键，指向一的一方的主键 多对多 - 如 学生 与 课程 的关系 - 一个学生可以选修多门课程，一门课程也可以供多个学生选择 - 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 连接查询 内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 外连接：查询所有的数据时，就一定会用到外连接。 左外连接：相当于查询A（左）表所有数据和交集部分数据 右外连接：相当于查询B（右）表所有数据和交集部分数据 满外连接：满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 自连接：当前表与自身的连接查询，自连接必须使用表别名 自连接查询，可以是内连接，也可以是外连接 联合查询-UNION , UNION ALL 把多次查询的结果合并起来，形成一个新的查询结果集 子查询 概念：查询中嵌套查询，称嵌套查询为子查询 子查询根据查询结果不同，作用不同，分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 子查询的外部语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个 根据子查询位置，分为：WHERE之后，FROM之后，SELECT之后。 内连接 12345-- 隐式内连接:没有JOIN关键字，条件使用WHERE指定SELECT 字段列表 FROM 表1，表2，…… WHERE 条件;-- 显示内连接:使用INNER JOIN ... ON语句, 可以省略INNERSELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 表连接条件 WHERE 查询条件; 外连接 12345678-- 左外连接:使用LEFT OUTER JOIN ... ON，OUTER可以省略SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 表连接条件 WHERE 查询条件;-- 右外连接SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 表连接条件 WHERE 查询条件;-- 其两者本质区别是表名的位置所在，一般情况下使用左外连接 自连接 1SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件…… ; 实例演示 连接关系图 联合查询(UNION) 123SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2 UNION 操作符返回两个查询的结果集的并集，去除重复记录。 UNION ALL 操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。 结论：如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。 实例演示 子查询 查询语法 12345678-- 单行单列：作为条件值，使用= != &gt; &lt; 等进行条件判断SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询);-- 多行单列：作为条件值，使用IN等关键字进行条件判断SELECT 字段列表 FROM 表 WHERE 字段名 in (子查询);-- 多行多列：作为虚拟表SELECT 字段列表 FROM (子查询) WHERE 条件; 标量子查询 子查询的结果返回单个值（数字，字符串，日期等），最简单的形式，称为标量子查询 常用操作符： = 、 &lt;&gt; 、 &gt; 、 &gt;= 、 &lt; 、 &lt;= 实例演示 列子查询 子查询的返回结果是一列（可以是多行），这种子查询称为列子查询。 常用操作符： IN 、 NOT IN 、 ANY 、 SOME 、 ALL 操作符 描述 IN 在指定的集合范围内多选一 NOT IN 不在指定的集合范围内 ANY 列子查询返回列表中，有任意一个满足即可 SOME 与ANY等同 ALL 子查询返回列表的所有值都必须满足 实例演示 行子查询 子查询返回的结果是一行（可以是多行），称为行子查询。 常用操作符： = 、 &lt;&gt; 、 IN 、 NOT IN 实例演示 表子查询 子查询返回的结果是多行多列，这种子查询称为表子查询。 常用操作符：IN 实例演示 查询总实例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127-- 部门表CREATE TABLE dept1(\tid INT PRIMARY KEY, -- 部门id\tdname VARCHAR(50), -- 部门名称\tloc VARCHAR(50) -- 部门所在地);-- 职务表，职务名称，职务描述CREATE TABLE job1(\tid INT PRIMARY KEY,\tjname VARCHAR(20),\tdescription VARCHAR(50));-- 员工表CREATE TABLE emp(\tid INT PRIMARY KEY, -- 员工id\tename VARCHAR(50), -- 员工姓名\tjob_id INT, -- 职务id\tmgr INT, -- 上级领导\tjoindata DATE, -- 入职日期\tsalary DECIMAL(7,2), -- 工资\tbonus DECIMAL(7,2), -- 奖金\tdept_id INT, -- 所在部门编号\tCONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job1(id),\tCONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept1(id)\t);\t-- 工资等级表CREATE TABLE salaryGrade( grade INT PRIMARY KEY, -- 级别\tlowSalary INT, -- 最低工资\theiSalary INT -- 最高工资\t);\t-- 添加四个部门INSERT INTO dept1(id,dname,loc) VALUES(10,&#x27;教研部&#x27;,&#x27;北京&#x27;),(20,&#x27;学工部&#x27;,&#x27;上海&#x27;),(30,&#x27;销售部&#x27;,&#x27;广州&#x27;),(40,&#x27;财务部&#x27;,&#x27;深圳&#x27;);-- 添加四个职务INSERT INTO job1 (id,jname,description) VALUES(1,&#x27;董事长&#x27;,&#x27;管理公司，接单&#x27;),(2,&#x27;经理&#x27;,&#x27;管理部门员工&#x27;),(3,&#x27;销售&#x27;,&#x27;向客人推销产品&#x27;),(4,&#x27;文员&#x27;,&#x27;使用办公软件&#x27;);-- 添加四个员工INSERT INTO emp(id,ename,job_id,mgr,joindata,salary,bonus,dept_id)VALUES(1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20),(1002,&#x27;猪八戒&#x27;,3,1006,&#x27;2001-1-5&#x27;,&#x27;3000.00&#x27;,NULL,10),(1003,&#x27;沙和尚&#x27;,2,1007,&#x27;2003-12-27&#x27;,&#x27;9000.00&#x27;,NULL,30),(1004,&#x27;唐僧&#x27;,1,1009,&#x27;2015-8-7&#x27;,&#x27;6000.00&#x27;,NULL,40);-- 添加五个工资等级INSERT INTO salaryGrade(grade,lowSalary,heiSalary)VALUES(1,3000,12000),(2,12000,16000),(3,16000,20000);-- 1、查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/*分析：\t1、员工编号，员工姓名，工资，信息在emp员工表中\t2、职务名称，职务描述，信息在job职务表中，\t3、job 和 emp 是 一对多的关系 emp.job_id = job.id*/-- 隐式内连接SELECT emp.id,ename,salary,jname,description FROM emp,job1 WHERE emp.job_id = job1.id;-- 显式内连接SELECT emp.id,ename,salary,jname,description FROM job1 INNER JOIN emp ON emp.job_id = job1.id;-- 2、查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置/*分析：\t1、员工编号，员工姓名，工资在emp表中\t2、职务名称，职务描述，在job1表中\t3、部门名称，部门位置，在dept1表中\t4、emp和dept1为一对多，emp和job1也为一对多*/-- 隐式内链接SELECT emp.id,emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc FROM emp,dept1,job1 WHERE dept1.id = emp.dept_id AND emp.job_id = job1.id; -- 显式内连接SELECT emp.id,emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc FROM emp INNER JOIN dept1 ON dept1.id = emp.dept_id INNER JOIN job1 ON emp.job_id = job1.id; -- 3、查询员工姓名，工资，工资等级/*分析：\t1、员工姓名在emp中，工资，\t2、工资等级在salarygrade中\t3、emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary*/-- 左外连接SELECT emp.ename,emp.salary,salarygrade.grade FROM emp LEFT OUTER JOIN salarygrade ON emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary;-- 4、查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级/*分析：\t1、员工姓名，工资，在emp\t2、职务名称，职务描述，在job1\t3、部门名称，部门位置，在dept1\t4、工资等级，在salarygrade*/-- 隐式内连接SELECT emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc,salarygrade.grade FROM emp,salarygrade,dept1,job1 WHERE emp.dept_id = dept1.id AND emp.job_id = job1.id AND emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary;-- 显式内连接SELECT emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc,salarygrade.grade FROM emp INNER JOIN job1 ON emp.job_id = job1.idINNER JOIN dept1 ON emp.dept_id = dept1.idINNER JOIN salarygrade ON emp.salary BETWEEN salarygrade.lowSalary AND salarygrade.heiSalary;-- 5、查询出部门编号，部门名称，部门位置，部门人数/*分析：\t1、部门编号，部门名称，部门位置属于dept\t2、部门人数：在dept1表中，按照dept_id进行分组，然后count（*）统计数量\t3、使用子查询，让部门表和分组后的表进行内连接*/SELECT dept_id,count(*) FROM emp GROUP BY dept_id;SELECT * FROM dept1,(SELECT dept_id,count(*) FROM emp GROUP BY dept_id) tWHERE dept1.id = t.dept_id; 考核错题 123456789-- 5.查询员工 及其 所属领导的名字 SELECT a.`NAME` &#x27;员工&#x27;,b.`NAME` &#x27;领导&#x27; FROM emp a,emp b WHERE a.managerid = b.id;-- 6.查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 -- 左外连接 #2SELECT a.`NAME` &#x27;员工&#x27;,b.`NAME` &#x27;领导&#x27; FROM emp a LEFT JOIN emp b ON a.managerid = b.id; -- 25.查询所有的部门信息, 并统计部门的员工人数select d.id, d.name , ( select count(*) from emp e where e.dept_id = d.id ) &#x27;人数&#x27;from dept d; 事务 简介 数据库的事务(transaction)是一种机制、一个操作序列，包含了一组数据库操作指令。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。 事务十一个不可分割的工作逻辑单元。 语法 123456789-- 开启事务START TRANSACTION;或者 BEGIN;-- 提交事务COMMIT;-- 回滚事务ROLLBACK; MySQL默认事务自动化提交 123456-- 查看事务的默认提交方式SELECT @@AUTOCOMMIT；-- 1 自动提交 0 手动提交-- 修改事务提交方式SET @@AUTOCOMMIT = 0; 代码演示 123456789101112131415161718192021222324252627282930313233DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account(\tid INT PRIMARY KEY auto_increment,\tname VARCHAR(10),\tmoney DOUBLE(10,2));-- 添加数据INSERT INTO account(name,money) VALUES(&#x27;张三&#x27;,1000),(&#x27;李四&#x27;,1000);SELECT * FROM account;UPDATE account SET money = 1000;-- 开始事务BEGIN;-- 转账操作-- 1、李四金额-500UPDATE account SET money = money - 500 WHERE name = &#x27;李四&#x27;;-- 错误。。。-- 2、张三金额+500UPDATE account SET money = money + 500 WHERE name = &#x27;张三&#x27;;-- 提交事务COMMIT；-- 回滚事务ROLLBACK; 事务四大特征(ACID) 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。 也就是说事务前后数据的完整性必须保持一致。 隔离性（Isolation） 隔离性是指一个事务的执行不能有其他事务的干扰，事务的内部操作和使用数据对其他的并发事务是隔离的，互不干扰。 持久性（Durability） 持久性是指一个事务一旦提交，对数据库中数据的改变就是永久性的。此时即使数据库发生故障，修改的数据也不会丢失。接下来其他的操作不会对已经提交了的事务产生影响。 并发事务问题（脏读、不可重复读、幻读) 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 比如在事务 A 修改数据之后提交数据之前，这时另一个事务 B 来读取数据，如果不加控制，事务 B 读取到 A 修改过数据，之后 A 又对数据做了修改再提交，则 B 读到的数据是脏数据，此过程称为脏读。 不可重复读 不可重复读是指在数据库访问中，一个事务范围内多次查询却返回了不同的数据值。这是由于在查询间隔中，其他事务修改并提交而引起的。 比如事务 T1 读取某一数据，事务 T2 读取并修改了该数据，T1 为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 幻读 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 比如事务 A 在按查询条件读取某个范围的记录时，事务 B 又在该范围内插入了新的满足条件的记录，当事务 A 再次按条件查询记录时，会产生新的满足条件的记录。 事务的四个隔离级别 未提交读（Read Uncommitted） 一个事务能够读取到别的事务中没有提交的更新数据。事务中的修改，即使没有提交，其他事务也可以看得到。在这种隔离级别下有可能发生脏读，不可重复读和幻读。 提交读（Read Committed） 事务中的修改只有提交以后才能被其它事务看到。在这种隔离级别下解决了脏读，但是有可能发生不可重复读和幻读。 可重复读（Repeated Read）(默认) 保证了在同一事务中先后执行的多次查询将返回同一结果，看到的每行的记录的结果是一致的，不受其他事务的影响。但是这种级别下有可能发生幻读。 可串行化（Serializable） 不允许事务并发执行，强制事务串行执行。就是在读取的每一行数据上都加上了锁，读写相互都会阻塞，所以效率很低下。这种隔离级别最高，是最安全的，但是性能最低，不会出现脏读，不可重复读，幻读。 注：隔离级别越高，数据安全性越高，但性能越低。 12345-- 查看事务隔离级别SELECT @@TRANSACTION_ISOLATION;-- 设置事务隔离级别SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;","tags":["MySQL"],"categories":["学习笔记"]},{"title":"MySQL-基础(1)","path":"/2023/05/22/MySQL-基础(1)/","content":"数据库相关概念 简介 关系型数据库是建立在关系模型基础上的数据库，即由多张能够相互连接的二维表组成。 MySQL体系结构（存储引擎） 连接层 最上层是一些客户端和连接服务，主要完成类似于连接处理、授权认证、及相关处理方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。 引擎层 存储引擎真正的负责了MySQL中数据的存储和获取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 存储层 主要是将数据存储在文件系统上，并完成存储引擎的交互。 SQL通用语法 可以单行或多行书写，以分号结尾。 不区分大小写，关键字建议大写。 注释： 单行注释：-- 内容 或 #内容 多行注释：/内容/ SQL分类 DDL 数据库定义语言( DATA DEFINITION LANGUAGE ) 用来定义数据对象：数据库、列、表…… DML 数据操作语言( DATA MANIPULATION LANGUAGE ) 用来对数据库中表的增删改 DQL 数据查询语言( DATA QUERY LANGUAGE ) 查询数据库中表的记录（数据） DCL 数据控制语言( DATA CONTROL LANGUAGE ) 定义数据库的访问权限和安全级别，及创建用户 DDL 数据定义语言 简介 DDL 数据库定义语言( DATA DEFINITION LANGUAGE ) 用来定义数据对象：数据库、列、表…… 操作数据库 查询数据库 - 创建数据库 - CREATE DATABASE 库名； - CREATE DATABASE IF NOT EXISTS 库名； 删除数据库 - DROP DATABASE 库名； - DROP DATABASE IF EXISTS 库名； 使用数据库 - USE 库名； 操作表 查询表：查询当前数据库下所有表的名称 - SHOW TABLES; 创建表 - CREATE TABLE 表名( - 字段名1 数据类型1， - 字段名2 数据类型2， - …… - ); 删除表 - DROP TABLE 表名； - DROP TABLE IF EXISTS 表名； 修改表 - 修改表名 - ALTER TABLE 原表名 RENAME TO 新表名； - 添加一列 - ALTER TABLE 表名 ADD 列名 数据类型； - 修改数据类型 - ALTER TABLE 表名 MODIFY 列名 新数据类型； - 修改列名和数据类型 - ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型； - 删除列 - ALTER TABLE 表名 DROP 列名； DML 数据操作语言 简介 DML 数据操作语言( DATA MANIPULATION LANGUAGE ) 用来对数据库中表的增删改 添加数据 插入数据时，指定的字段顺序需要与值的顺序是一一对应的 字符串和日期型数据应该包含在引导中 插入的数据大小，应该在字段的规定范围内 1234567-- 给指定列添加数据 INSERT INTO 表名(列名1，列名2，……) VALUES(值1，值2，……);-- 给全部列添加数据 INSERT INTO 表名 VALUES(值1，值2，……);-- 批量添加 INSERT INTO 表名 (列1，列2，……) VALUES(值1，值2，……),(值1，值2，……)，……; INSERT INTO 表名 VALUES(值1，值2，……),(值1，值2，……)，……; 修改数据 1UPDATA 表名 SET 列名1 = 值1，列名2 = 值2，…… [WHERE 条件]； 注：修改语句中如果不加条件，将修改所有数据 删除数据 1DELETE FROM 表名[WHERE 条件]; DQL 数据查询语言 简介 DQL 数据查询语言( DATA QUERY LANGUAGE ) 查询数据库中表的记录（数据） 基础查询 123456789101112-- 查询多个字段SELECT 列名1，列名2，...FROM 表名;SELECT * FROM 表名;-- (直接查询全部)注：不建议使用第二种，使得代码可读性降低。-- 设置别名SELECT 字段1[AS 别名1],字段2[AS 别名2],... FROM 表名;-- AS可以省略-- 去除重复记录SELECT DISTINCT 字段列表 FROM 表名; 条件查询 WHERE SELECT 字段列表 FROM 表名 WHERE 条件列表； 条件 符号 功能 &gt;= 大于等于 &lt;= 小于等于 &lt; 小于 &gt; 大于 &lt;&gt; 或 != 不等于 = 等于 BETWEEN …AND… 在某个范围内 （数值范围从小到大，否则查询不到） AND 或 &amp;&amp; 并且 OR 或 || 或者 IN(…) 多选一 NOT 或 ！ 非，不是 IS NULL 是空 IS NOT NULL 非空 LIKE 占位符 模糊查询： _单个任意字符 %多个任意字符 | 注：NULL值得比较不能用= != ，需要用IS IS NOT; BETWEEN…AND和IN(…)区别：前者是取值范围内允许，后者是具体值选其一 排序查询 ORDER BY SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1[排序方式1] , 排序字段名2[排序方式2] , ……； 排序方式 - ASC：升序（默认） - DESC：降序 注：有多个条件时，当前边条件值一样时，才会根据第二个条件进行排序 分组查询 GROUP BY 聚合函数 概念： 将一列数据作为一个整体，纵向计算。所有NULL值不参与运算 分类 函数名 功能 COUNT(列名) 统计数量（一般不为NULL值） 列名取值：1. 主键 ，2. * MAX(列名) 最大值 MIN(列名) 最小值 SUM(列名) 求和 AVG(列名) 求平均 分组查询语法 SECLECT 聚合函数(字段列表) FROM 表名 [WHERE 分组前提条件限定] GROUP BY 分组字段名 [HAVING 分组后过滤条件]； 注：分组后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义。 WHERE 和 HAVING 的区别 执行时机不同：WHERE 时分组之前进行条件限定，不满足WHERE条件则不参与分组，而HAVING是分组后对结果进行过滤。 可判断的条件不同：WHERE 不能对聚合函数进行判断，HAVING 可以。 执行顺序：WHERE &gt; 聚合函数 &gt; HAVING 分页查询 LIMIT(MySQL专用) SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询条目数； 计算公式：起始索引 = （当前页码 - 1） 每页显示条数* 查询的执行顺序 FROM… -&gt;WHERE… -&gt;SELECT… -&gt;ORDER BY… -&gt;LIMIT… DCL 数据控制语言(不常用) 简介 DCL 数据控制语言( DATA CONTROL LANGUAGE ) 定义数据库的访问权限和安全级别，及创建用户 管理用户 查询用户 12USE 用户名;SELECT * FROM user; 创建用户 1CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;; 修改用户密码 1ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;; 删除用户 1DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; 权限控制 查询权限 1SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;; 授予权限 1GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;; 撤销权限 1REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;","tags":["MySQL"],"categories":["学习笔记"]},{"title":"友链","path":"/friends/index.html","content":"还没挂友链"},{"title":"关于本站","path":"/about/index.html","content":"尊敬的读者们： 欢迎来到我的个人博客。在创建网站的过程中，为丰富网站内容并提供多元化视角，作者在学习的过程中， 部分学习笔记等文章会整合互联网上各种优质资源，不限于 CSDN、OS China、掘金、Github等。 在此声明，一切文章仅为作者学习时笔记的整合和记录，无恶意搬运。 若有侵权，请立即联系作者删除。 如果您有任何疑问或者建议，欢迎您随时与我联系。邮箱：[3086660647@qq.com] 谢谢！ Echo"},{"title":"更多","path":"/more/index.html","content":"没有更多"}]