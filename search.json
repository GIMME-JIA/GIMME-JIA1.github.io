[{"title":"2023年度总结","path":"/2023/12/31/2023年度总结/","content":"到今天，Java 的学习历程也有一年之久了吧…… 一月份的时候刚开始接触 Java，那时还懵懂无知的我连 C 都学的一塌糊涂就草草跟着 web 开始了 Java 的学习。各种基础语法跟 C 总是搞混，记得当时因为 int arr[] = new int[] 看了一整天，现在想想真是又蠢又好笑。尤其是在学面向对象的时候，对于当时的我来说真的真的很难，我很不理解封装多态那些东西，我也不明白为什么又要 private 又要给他个 getter 和 setter。很多时候一坐就是一天，想一些自己无法理解又无关紧要的问题，这些别人一眼就懂的东西我却百思不得其解。二者或许是因为学长学姐不太合理的计划安排和并不专业化的知识点讲解，很多东西只是粗略的一笔带过便按部就班的留作业了。好在这也激发了一下自己找资料自学的能力，在 b 站浅显的补了一点黑马的课（阿伟讲的是真的好），才勉强跟上 web 的进度。我本身是一个依赖性很强且不自信的人，总把希望寄托在别人身上，中学的时候想着老师带我拿高分，成绩差了指望补习班，上了大学觉得进科协能令我高人一等之类的，但现实的巴掌终于在这个寒假把我打醒了。为了不被 web 踢掉，使得从来没有去过图书馆自习室自学的我不得已踏出了舒适区，满是艰辛和焦虑的熬过了这个寒假。 到三月中下旬开始学习黑马的数据库（只学了 crud 到事务那部分），再到四月上旬开始老杜的 Javaweb，我真正感受到了 Java 学习的不容易，这门课对于当时的我仿佛天书一样，太多的知识都是我不曾接触和了解过的，只想着能不能跟着一点一点敲代码去记忆再理解，那段时间的学习频率很高，但效率却很低，但好在老杜那门课讲的确实很好，尤其是对于我这种新手小白，但好多深入源码的东西我都没懂，虽然我学的时候并不理解透彻，但不断反复的敲一样的代码和解释每一个知识点，都给我留下了较为深刻的印象，使得我在后期接触到相关知识点的时候都能想到是哪一部分的知识点，并回来查阅笔记，结合着当前知识点去加深理解，强化记忆。 等开始学 ssm 的时候已经五月中了，黑马的那套 ssm 听的我简直是怀疑人生，给我一种前所未有的茫然感，使得我一度怀疑自己前面那些时间到底在学的什么，但我还是咬着牙跟着做笔记把它看完。知识链断了，想必是前面的 Javaweb 没学明白。于是我又在五月底的时候刷了一遍黑马的 23 版 Javaweb，不得不说，黑马的组合课只适合有一定水平的选手啊，感觉老杜和黑马讲的完全不是一个层次，老杜的比较偏向原理和基础，黑马这门更偏向于新技术吧，但很多东西都是一笔带过，不过我也在这其中接触了更为广泛的新知识，比如 vue。并且在六月底期末考 Java 的时候还把之前没怎么学的进阶部分像 io 流、多线程、网络编程以及反射等给补上了。 我又开始重新找方向，既然组合课看的吃力，就拆出来一点点学。七月初期末结束后，趁着留校的一点时间，先后将老杜的 spring6 和 mybatis 刷完，每天泡在实验室，肝到凌晨一两点，循环往复，度过了这煎熬而充实的半个月时间，这两门课虽然时间长了点，讲的却非常全面，而且还带着实现了相关的简易框架来理解其底层原理（虽然现在也忘得差不多了）。七月底的时候才把 springmvc 学完，但也丝毫不敢懈怠，八月份直接开始 springboot。可能是有点太过于匆忙，这些课感觉好像都是只是过了一遍脑子，笔记也是偷懒，直接用的资料边看边学，报着没必要都听懂，留个印象，后续有需要再查资料即可的心态去学的。八月中学完 springboot 便开了苍穹外卖，对于第一次做这种具有一定架构且技术栈应用广泛的项目，像 httpclient，springtask 这些，跟着视频学到将近一半也只不过是学会了 crud 的流程，很多业务流程并不懂得如何自己去分析和编写代码，但好在大多数业务繁而不难，多敲几遍也都能有一个大概的了解。更重要的是，这个项目的学习中，使得我学会了如何去阅读和调试接口，这一点也让我觉得自己并没有完全白学，有了点小小的成就感吧。 八月底开学，大二开始，但我的苍穹外卖却九月中下旬才敲完。由于学校的课程太多，再加上乱七八糟的实验作业，自学的时间大幅减少，便趁着十月国庆期间学了一下 springcloud，但也只学到了 docker，发现自己很多相关技术栈都没有学， 于是花了将近两星期将 linux 系统学习了一下，还搭建了一个自己的网站博客来记录学习。十月下旬，眼看着数据结构的课快跟不上了，因为前期看王道的课，基本都是理解而并没有系统的跟着去敲代码，于是开了黑马的课，讲的确实不错，而且还是 Java 授课。与此同时，十一月初的时候还做了自己的第一版简历，试着开始投实习，即使无功而返，但也逐渐了解到自己的不足之处和不断规划学习的方向。到十二月上旬，已经把数据结构过了一遍。当然，因为一些时候想当然的去赶进度，像红黑树 b 树这些复杂的知识点只是浅显的过了一遍，计划后续跟随想录的时候再去加强学习了。中下旬的时候把黑马的 redis 看到了 redissdion 部分，听着很吃力，发现自己的基础很多东西都没学，便又折回来在学习了 jvm 的基础部分，感觉实战调优那些的对于这个时期的我来说并不需要过多的学习，后期有需要的话回来再看了。月底 27 号开始并发编程，到现在已经看到三分之一了，哈哈。 这整一年，太多的困难和焦虑，尤其是从大一下接触牛客开始，看了各种面经和实习要求，自己都是一头雾水，无从开口；还有大家惊人的学习速度，甚至能四五个月学完 springboot，使得我每天都在焦虑中度过，觉得自己进度慢，学习效率底，总怀疑自己这条路是不是真的适合我。但在慢慢深入了解后，也学着去放平心态，把握当下的学习进度，一步一步脚踏实地，懂得了如何面对和缓解焦虑，很感谢在牛客上认识的道友们，乐于分享知识，相互学习，他们不仅让我看到了自己与同龄人的差距，更是打破了我的信息差，实习、工作等方面的认知壁垒，每个人都是我值得学习的榜样。 希望在这新的一年，预计在大二下学期开学前把并发、mysql 进阶那块还有 redis、springcloud 剩下的学完，完善自己的技术栈，然后开学的时候将更多的时间投入到项目、八股，多投多面，为暑期实习夯实基础，做好准备。大三的事就以后再说吧，说远了也不一定做得到。尤其是 leecode，一直没有持续刷题的习惯，总是想起来就做，不想做就犯懒，做了不会的时候就开摆。 还有计网、os 这些基础的学习，原本还想着做几个轮子项目的，像数据库内核，rpc 这些， 但考虑时间并不是很富裕和自己学习的掌握程度，也不知道该怎么安排了，这一直是个头疼的点。 相比于技术栈，更重要的是，对于自己的编码规范、代码风格、业务逻辑、问题分析和 bug 调试等能力的锻炼培养也是不可忽视的。总之，新的一年，新的挑战，誓将以饱满的热情和不挠的意志去面对攻克每一个技术难题，为更强大的自己，加油！！！","categories":["心得总结"]},{"title":"并发-基础知识","path":"/2023/12/29/并发-基础知识/","content":"进程和线程 进程 进程：程序是静止的，进程实体的运行过程就是进程，是系统进行资源分配的基本单位。 进程的特征：并发性、异步性、动态性、独立性、结构性。 线程 线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统独立调度的基本单位，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源。 线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能。 关系 一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程。 线程进程对比 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。 进程拥有共享的资源，如内存空间等，供其内部的线程共享。 进程间通信较为复杂：同一台计算机的进程通信称为IPC（Inter-process communication） 信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件 共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问。 管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持半双工通信。 匿名管道（Pipes）：用于具有亲缘关系的父子进 、程间或者兄弟进程之间的通信。 命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO。 消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供全双工通信，对比管道： 匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除。 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP 套接字：与其它通信机制不同的是，可用于不同机器间的互相通信。 线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。 Java 中的通信机制：volatile、等待/通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer。 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。 并发和并行 并行：在同一时刻，有多个指令在多个 CPU 上同时执行。 并发：在同一时刻，有多个指令在单个 CPU 上交替执行。 同步和异步 需要等待结果返回，才能继续运行就是同步。 不需要等待结果返回，就能继续运行就是异步。 Java 中创建线程的几种方式 Thread Thread 创建线程方式：创建线程类，匿名内部类方式。 start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行。 线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程。 建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完。 Thread 构造器： public Thread() public Thread(String name) 12345678910111213141516171819public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.start(); for(int i = 0 ; i &lt; 100 ; i++ )&#123; System.out.println(&quot;main线程&quot; + i); &#125; // main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行 &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; for(int i = 0 ; i &lt; 100 ; i++ ) &#123; System.out.println(&quot;子线程输出：&quot;+i); &#125; &#125;&#125; 继承 Thread 类的优缺点： 优点：编码简单 缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）。 Runnable Runnable 创建线程方式：创建线程类，匿名内部类方式 Thread 的构造器： public Thread(Runnable target) public Thread(Runnable target, String name) 1234567891011121314151617public class ThreadDemo &#123; public static void main(String[] args) &#123; Runnable target = new MyRunnable(); Thread t1 = new Thread(target,&quot;1号线程&quot;); t1.start(); Thread t2 = new Thread(target);//Thread-0 &#125;&#125;public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for(int i = 0 ; i &lt; 10 ; i++ )&#123; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i); &#125; &#125;&#125; Thread 类本身也是实现了 Runnable 接口，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run： 12345678910public class Thread implements Runnable &#123; private Runnable target; public void run() &#123; if (target != null) &#123; // 底层调用的是 Runnable 的 run 方法 target.run(); &#125; &#125;&#125; Runnable 方式的优缺点： 缺点：代码复杂一点。 优点： 1. 线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性。 2. 同一个线程任务对象可以被包装成多个线程对象。 3. 适合多个多个线程去共享同一个资源。 4. 实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立。 5. 线程池可以放入实现 Runnable 或 Callable 线程任务对象。 Callable 实现 Callable 接口： 定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型 重写线程任务类的 call 方法，这个方法可以直接返回执行的结果 创建一个 Callable 的线程任务对象 把 Callable 的线程任务对象包装成一个未来任务对象 把未来任务对象包装成线程对象 调用线程的 start() 方法启动线程 public FutureTask(Callable callable)：未来任务对象，在线程执行完后得到线程的执行结果。 FutureTask 就是 Runnable 对象，因为 Thread 类只能执行 Runnable 实例的任务对象，所以把 Callable 包装成未来任务对象。 线程池部分详解了 FutureTask 的源码。 public V get()：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步。 get() 线程会阻塞等待任务执行完成。 run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值。 优缺点： 优点：同 Runnable，并且能得到线程执行的结果 缺点：编码复杂 1234567891011121314151617181920public class ThreadDemo &#123; public static void main(String[] args) &#123; Callable call = new MyCallable(); FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(call); Thread t = new Thread(task); t.start(); try &#123; String s = task.get(); // 获取call方法返回的结果（正常/异常结果） System.out.println(s); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class MyCallable implements Callable&lt;String&gt; &#123; @Override//重写线程任务类方法 public String call() throws Exception &#123; return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;; &#125;&#125; 查看进程线程的方法 windows 任务管理器可以查看进程和线程数，也可以用来杀死进程 （Ctrl+Shift+Esc） tasklist查看进程 taskkill杀死进程 linux ps -fe查看所有进程 ps -fT -p 查看某个进程（PID）的所有线程 kill杀死进程 top按大写 H 切换是否显示线程 top -H -p 查看某个进程（PID）的所有线程 Java jps 命令查看所有 Java 进程 jstack 查看某个 Java 进程（PID）的所有线程状态 jconsole 来查看某个 Java 进程中线程的运行情况（图形界面） 线程方法 Thread 类 API 方法 说明 public void start() 启动一个新线程，Java虚拟机调用此线程的 run 方法。start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException。 public void run() 线程启动后调用该方法。如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为。 public void setName(String name) 给当前线程取名字 public void getName() 获取当前线程的名字。 线程存在默认名称：子线程是 Thread-索引，主线程是 main。 public static Thread currentThread() 获取当前线程对象，代码在哪个线程中执行 public static void sleep(long time) 让当前线程休眠多少毫秒再继续执行 Thread.sleep(0) : 让操作系统立刻重新进行一次 CPU 竞争 public static native void yield() 提示线程调度器让出当前线程对 CPU 的使用 public final int getPriority() 返回此线程的优先级 public final void setPriority(int priority) 更改此线程的优先级，java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率，常用 1(最小) 5(默认) 10(最大) public void interrupt() 判断当前线程是否被打断，如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记；park 的线程被打断，也会设置打断标记。 public static boolean interrupted() 判断当前线程是否被打断，会清除打断标记。 public boolean isInterrupted() 判断当前线程是否被打断，不清除打断标记。 public final void join() 等待这个线程结束 f public final void join(long millis) 等待这个线程结束 millis 毫秒，0 意味着永远等待。 public final native boolean isAlive() 线程是否存活（还没有运行完毕）。 public final void setDaemon(boolean on) 将此线程标记为守护线程或用户线程。 run 和 start run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行。 start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码。 说明：线程控制资源类 run() 方法中的异常不能抛出，只能 try/catch。 因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常。 异常不能跨线程传播回 main() 中，因此必须在本地进行处理。 sleep 和 yield sleep： 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。 sleep() 方法的过程中，线程不会释放对象锁。 其它线程可以使用interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException。 睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU。 建议用TimeUnit 的 sleep 代替 Thread 的 sleep来获得更好的可读性。 yield： 调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用。 具体的实现依赖于操作系统的任务调度器。 会放弃 CPU 资源，锁资源不会释放。 线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 interrupt 打断线程 public void interrupt()：打断这个线程，异常处理机制 public static boolean interrupted()：判断当前线程是否被打断，打断返回 true，清除打断标记，连续调用两次一定返回 false。 public boolean isInterrupted()：判断当前线程是否被打断，不清除打断标记。 打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）。 sleep、wait、join 方法都会让线程进入阻塞状态，打断线程会清空打断状态（false）。 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;t1&quot;); t1.start(); Thread.sleep(500); t1.interrupt(); System.out.println(&quot; 打断状态: &#123;&#125;&quot; + t1.isInterrupted());// 打断状态: &#123;&#125;false&#125; 打断正常运行的线程：不会清空打断状态（true） 123456789101112131415public static void main(String[] args) throws Exception &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; Thread current = Thread.currentThread(); boolean interrupted = current.isInterrupted(); if(interrupted) &#123; System.out.println(&quot; 打断状态: &#123;&#125;&quot; + interrupted);//打断状态: &#123;&#125;true break; &#125; &#125; &#125;, &quot;t2&quot;); t2.start(); Thread.sleep(500); t2.interrupt();&#125; 两阶段中止模式 “两阶段中止”（Two-Phase Termination）并不是一个传统的设计模式，而是一种处理线程终止的编程模式。这种模式的核心思想是在终止线程时采取两个阶段，确保线程在退出之前完成必要的清理工作，从而提高程序的健壮性和稳定性。 目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器。 错误思想： 使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。 使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止。 正确思路： 通常，&quot;两阶段中止&quot;包含以下两个阶段： 第一阶段：通知线程终止。 在这个阶段，通过设置一个标志或调用线程的 interrupt() 方法来通知线程需要终止。线程在被通知后，可以根据具体的业务逻辑决定是否立即退出。 第二阶段：线程执行清理工作。 如果线程在第一阶段接收到终止通知后未立即退出，它将在第二阶段执行必要的清理工作，确保资源的正确释放和状态的正确处理。这可以在 run 方法中进行。 123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; TwoPhaseTermination tpt = new TwoPhaseTermination(); tpt.start(); Thread.sleep(3500); tpt.stop(); &#125;&#125;class TwoPhaseTermination &#123; private Thread monitor; // 启动监控线程 public void start() &#123; monitor = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; Thread thread = Thread.currentThread(); if (thread.isInterrupted()) &#123; System.out.println(&quot;后置处理&quot;); break; &#125; try &#123; Thread.sleep(1000); // 睡眠 System.out.println(&quot;执行监控记录&quot;);\t// 在此被打断不会异常 &#125; catch (InterruptedException e) &#123; // 在睡眠期间被打断，进入异常处理的逻辑 e.printStackTrace(); // 重新设置打断标记，打断 sleep 会清除打断状态 thread.interrupt(); &#125; &#125; &#125; &#125;); monitor.start(); &#125; // 停止监控线程 public void stop() &#123; monitor.interrupt(); &#125;&#125; 打断 park park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）。 1234567891011public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; System.out.println(&quot;park...&quot;); LockSupport.park(); System.out.println(&quot;unpark...&quot;); System.out.println(&quot;打断状态：&quot; + Thread.currentThread().isInterrupted());//打断状态：true &#125;, &quot;t1&quot;); t1.start(); Thread.sleep(2000); t1.interrupt();&#125; 如果打断标记已经是 true, 则 park 会失效。 1234LockSupport.park();System.out.println(&quot;unpark...&quot;);LockSupport.park();//失效，不会阻塞System.out.println(&quot;unpark...&quot;);//和上一个unpark同时执行 可以修改获取打断状态方法，使用 Thread.interrupted()，清除打断标记。 LockSupport 类在 同步 → park-un 详解 daemon public final void setDaemon(boolean on)：如果是 true ，将此线程标记为守护线程 线程启动前调用此方法： 123456789Thread t = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;running&quot;); &#125;&#125;;// 设置该线程为守护线程t.setDaemon(true);t.start(); 用户线程：平常创建的普通线程 守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示。 说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去 常见的守护线程： 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 已废弃 API 不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁： public final void stop()：停止线程运行废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面。 public final void suspend()：挂起（暂停）线程运行废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果恢复目标线程的线程在调用 resume 之前会尝试访问此共享资源，则会导致死锁。 public final void resume()：恢复线程运行。 线程运行原理 运行机制 Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程。 线程的 CPU 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park 等方法 程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的。 当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。 JVM 规范并没有限定线程模型，以 HotSopot 为例： Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈） 线程的调度是在内核态运行的，而线程中的代码是在用户态运行，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能 Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程。 线程调度 线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）。 协同式线程调度：线程的执行时间由线程本身控制 优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题 缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃 抢占式线程调度：线程的执行时间由系统分配 优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用 缺点：无法主动为某个线程多分配时间 Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用。 说明：并不能通过优先级来判断线程执行的先后顺序。 未来优化 内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多个用户线程映射到一个内核级线程），被设计为协同式调度，所以叫协程。 有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程 无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限 有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器： 执行过程：用于维护执行现场，保护、恢复上下文状态 调度器：负责编排所有要执行的代码顺序 线程状态 操作系统层面描述 进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态。 从操作系统层面描述： 【初始状态】 仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态） 指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 【运行状态】 指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 【终止状态】 表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 Java API 层面描述 线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中java.lang.Thread.State 这个枚举中给出了六种线程状态： 线程状态 导致状态发生条件 NEW（新建） 线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征 Runnable（可运行） 线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法） Blocked（阻塞） 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 Waiting（无限等待） 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒 Timed Waiting （限期等待） 有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait Teminated（结束） run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡","tags":["并发编程"],"categories":["学习笔记"]},{"title":"JVM-类的生命周期","path":"/2023/12/25/JVM-类的生命周期/","content":"生命周期概述 在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。 按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，完整生命周期包括如下 7 个阶段： 加载 Loading 连接 Linking 验证 准备 解析 初始化 Initization 使用 Using 卸载 Unloading 加载阶段 Loading 类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。 程序员可以使用Java代码拓展的不同的渠道，如：本地磁盘上的文件，程序运行时动态代理生成的类（Spring 的 IoC），使用早期的 Applet 技术进行网络传输的类。 类加载器在加载完类之后，Java 虚拟机会将字节码中的信息保存到方法区中。（方法区只是一个虚的概念） 在方法区中生成一个 InstanceKlass 对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。 Java 虚拟机还会在堆中生成一份与方法区中数据类似的 java.lang.Class 对象。作用是在 Java 代码中去获取类的信息，也就是反射的由来。里面会包含字段、方法等信息。 并且， 堆区的** java.lang.Class** 对象和方法区的InstanceKlass 对象之间会通过一个引用彼此关联。除此之外， jdk8 以后，堆区的 java.lang.Class 对象还会存放静态字段的数据。jdk8 之前存放在方法区。 思考题 问：为什么是创建两个对象而不是一个？ 答： 1、首先，方法区的InstanceKlass对象是通过 C++来编写的，Java 代码无法直接操作，所以 Java 虚拟机就在堆区创建了一个使用 Java 语言包装的 java.lang.Class 对象，可以在代码中获取到。 2、堆区的java.lang.Class 对象中的字段会少于方法区的InstanceKlass对象中的字段，比如虚方法表，这是 Java 虚拟机底层实现多态使用的，而对于开发者来说，只需要访问堆区中的** java.lang.Class** 对象而不需要访问方法区中所有的信息。也很好的控制开发者访问数据的范围。 查看内存中的对象 可以使用 JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar中。 启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB jps：展示所有的 java 进程号 连接阶段 Linking 1.验证 验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。 主要包含如下四部分，具体详见《Java虚拟机规范》： 文件格式验证，比如文件是否以0xCAFEBABE开头（即魔数是否正确），主次版本号是否满足当前Java虚拟机版本要求。 元信息验证，例如类必须有父类（super不能为空）。 验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。 符号引用验证，例如是否访问了其他类中private的方法等。 验证案例-版本号的检测 2.准备 一般情况 准备阶段会为静态变量（static）分配内存并设置初始值，而不会直接对静态变量赋值，而将 value 的值变成 1 会在初始化阶段完成。 各数据类型对应的初始值 如果不对静态变量设置初始值，那么在该内存可能会残留之前的无关数据，影响提高代码的可读性、可维护性，难以避免潜在的错误。 final 修饰 final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值，包括字符串。 注：本章涉及到的内存结构只讨论JDK8及之后的版本，8之前的版本后续章节详述。 3.解析 将常量池中的符号引用替换成指向内存的直接引用 符号引用就是在字节码文件中使用编号来访问常量池中的内容。 直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。 初始化阶段 Initialization 初始化阶段会执行静态代码块中的代码，并为静态变量赋值 初始化阶段会执行字节码文件中clinit部分的字节码指令 clinit：cl 表示 class ，init 表示初始化，即类的初始化 初始化案例分析 将代码两句 顺序颠倒 Snipaste_2023-12-23_13-03-02.png 由此可见，clinit方法中的执行顺序与Java中编写的顺序是一致的。 使类初始化的几种方式 访问一个类的静态变量或者静态方法的时候，会初始化这个类。 注：如果变量是 final 修饰的并且等号右边是常量不会触发初始化。如果赋值的内容需要执行指令才能得到结果，会执行 clinit 方法进行初始化。 调用 Class.forName(String className)。 注：Class.forName 是个重载方法，也可以指定不初始化。 指定 initialize 通过 new 关键字创建该对象。 执行 Main 方法的当前类。 **添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类 ** clinit 指定不会出现的情况 无静态代码块且无静态变量赋值语句。 有静态变量声明，但没有赋值语句。 静态变量的定义使用 final 关键字，这类变量会在准备阶段进行初始化。 初始化试题 求运行结果 new的执行顺序：实例代码块-&gt;构造函数。初始化只会加载静态区中的数据，且静态区数据只会加载一次，所以是DACBCB。 求运行结果 结果：答案为 2，子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。 将 new B02()去掉，结果会怎么样？ 结果：答案为 1，直接访问父类的静态变量，不会触发子类的初始化。 求运行结果 12345678910public class Demo &#123; public static void main(String[] args) &#123; Demo2[] a = new Demo2[10]; &#125;&#125;class Demo2&#123; static &#123; System.out.println(&quot;静态代码块run&quot;); &#125;&#125; 结果：答案是控制台为空，因为数组的创建不会导致数组元素的类进行初始化 求运行结果 123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Demo2.a); &#125;&#125;class Demo2&#123; public static final int a = Integer.valueOf(1); static &#123; System.out.println(&quot;静态代码块run&quot;); &#125;&#125;// 控制台：// 静态代码块run// 1 结果：final 修饰的变量如果赋值的内容需要执行指令才能得到结果，会执行 clinit 方法进行初始化。 使用阶段 Using 不做赘述 卸载阶段 Unloading","tags":["JVM"],"categories":["学习笔记"]},{"title":"JVM-字节码文件","path":"/2023/12/24/JVM-字节码文件/","content":"字节码文件的组成 基本信息 包含了字节码文件的版本信息和其他一些元数据。字节码文件头部的魔数（ca fe ba be）用于告诉Java虚拟机，这个文件是一个合法的Java类文件，它可能会包含一些其他的元数据，例如编译器版本信息（JDK版本 = 主版本号 - 44），字节码文件的编译日期、父类和接口等。 常量池 包含了程序中使用到的各种常量，这些常量包括数字、字符串、类名、方法名等等。Java虚拟机在运行时需要用到常量池，因为Java虚拟机中的很多指令操作都需要用到常量池中的一些值。 字段 描述了一个类中的所有字段。字段包括其类型、名称和访问标志。在Java中，所有类中都有构造器和至少一个初始化方法（主方法）。 方法 描述了一个类中的所有方法。方法包括其名称、参数类型和返回类型，同时也包括方法的字节码指令和异常处理信息。通过这些方法，Java虚拟机能够理解程序中要执行的代码逻辑。 属性 这一部分用于保存一些额外的元数据，例如Java中的注解信息等。 接口 描述了所有实现或继承的接口。接口是Java中一种很重要的方式，用于描述要实现或者继承的共同特征和行为。它们允许Java程序员通过一个类继承和实现多种类型，从而获得最大程度的复用和可扩展性。 字节码常用工具 阿里 Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。 官网：https://arthas.aliyun.com/doc/ dump 类的全限定名：dump已加载类的字节码文件到特定目录。 jad 类的全限定名： 反编译已加载类的源码。 启动 Arthas： java -jar arthas-boot.jar jclasslib 既有 pc 端 app，也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码文件内容。 Github地址： https://github.com/ingokegel/jclasslib javap -v 命令 javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件容。 直接输入javap查看所有参数。 输入javap -v 字节码文件名称 查看具体的字节码息。（如果jar包需要先使用 jar –xvf 命令解压） 阅读字节码文件 ”显示 jvm 规范“看查看每条字节码指令所表示含义 字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。","tags":["JVM"],"categories":["学习笔记"]},{"title":"数据结构—递归","path":"/2023/12/11/数据结构-递归/","content":"1) 概述 定义 计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集 In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. 说明： 自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的） 每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归 内层函数调用（子集处理）完成，外层函数才能算调用完成 思路 确定能否使用递归求解 推导出递推关系，即父问题与子问题的关系，以及递归的结束条件 深入到最里层叫做递 从最里层出来叫做归 在递的过程中，外层函数内的局部变量（以及方法参数）并未消失，归的时候还可以用到 2) 单路递归 Single Recursion E01. 阶乘 用递归方法求阶乘 阶乘的定义 n!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅nn!= 1⋅2⋅3⋯(n-2)⋅(n-1)⋅nn!=1⋅2⋅3⋯(n−2)⋅(n−1)⋅n，其中 nnn 为自然数，当然 0!=10! = 10!=1 递推关系 f(n)={1n=1n∗f(n−1)n&gt;1f(n) = \\begin{cases} 1 &amp; n = 1\\\\ n * f(n-1) &amp; n &gt; 1 \\end{cases} f(n)={1n∗f(n−1)​n=1n&gt;1​ 代码 123456private static int f(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * f(n - 1);&#125; E02. 反向打印字符串 用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置 递：n 从 0 开始，每次 n + 1，一直递到 n == str.length() - 1 归：从 n == str.length() 开始归，从归打印，自然是逆序的 递推关系 f(n)={停止n=str.length()f(n+1)0≤n≤str.length()−1f(n) = \\begin{cases} 停止 &amp; n = str.length() \\\\ f(n+1) &amp; 0 \\leq n \\leq str.length() - 1 \\end{cases} f(n)={停止f(n+1)​n=str.length()0≤n≤str.length()−1​ 代码为 1234567public static void reversePrint(String str, int index) &#123; if (index == str.length()) &#123; return; &#125; reversePrint(str, index + 1); System.out.println(str.charAt(index));&#125; E03. 二分查找（单路递归） 1234567891011121314151617public static int binarySearch(int[] a, int target) &#123; return recursion(a, target, 0, a.length - 1);&#125;public static int recursion(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return recursion(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return recursion(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; E04. 冒泡排序（单路递归） 12345678910111213141516171819202122232425public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 4, 7&#125;; bubble(a, 0, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void bubble(int[] a, int low, int high) &#123; if(low == high) &#123; return; &#125; int j = low; for (int i = low; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); j = i; // j将指向右边最大的元素，即右边界 &#125; &#125; bubble(a, low, j);&#125;private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125; low 与 high 为未排序范围 j 表示的是未排序的边界，下一次递归时的 high 发生交换，意味着有无序情况 最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1 已然有序 E05. 插入排序（单路递归） 123456789101112131415161718192021public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 7, 4&#125;; insertion(a, 1, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void insertion(int[] a, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low - 1; int t = a[low]; while (i &gt;= 0 &amp;&amp; a[i] &gt; i) &#123; a[i + 1] = a[i]; i--; &#125; if(i + 1 != low) &#123; a[i + 1] = t; &#125; insertion(a, low + 1, high);&#125; 已排序区域：[0 … i … low-1] 未排序区域：[low … high] E06. 约瑟夫问题（单路递归） nnn 个人排成圆圈，从头开始报数，每次数到第 mmm 个人（mmm 从 111 开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？ 方法1 根据最后的存活者 a 倒推出它在上一轮的索引号 f(n,m) 本轮索引 为了让 a 是这个索引，上一轮应当这样排 规律 f(1,3) 0 x x x a (0 + 3) % 2 f(2,3) 1 x x x 0 a (1 + 3) % 3 f(3,3) 1 x x x 0 a (1 + 3) % 4 f(4,3) 0 x x x a (0 + 3) % 5 f(5,3) 3 x x x 0 1 2 a (3 + 3) % 6 f(6,3) 0 x x x a 方法2 设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始 f(n, m) 解 规律 f(1, 3) 0 f(2, 3) 0 1 =&gt; 1 3%2=1 f(3, 3) 0 1 2 =&gt; 0 1 3%3=0 f(4, 3) 0 1 2 3 =&gt; 3 0 1 3%4=3 f(5, 3) 0 1 2 3 4 =&gt; 3 4 0 1 3%5=3 f(6, 3) 0 1 2 3 4 5 =&gt; 3 4 5 0 1 3%6=3 一. 找出等价函数 规律：下次报数的起点为 k=m%nk = m \\% nk=m%n 首次出列人的序号是 k−1k-1k−1，剩下的的 n−1n-1n−1 个人重新组成约瑟夫环 下次从 kkk 开始数，序号如下 k, k+1, ... , 0, 1, k−2k,\\ k+1, \\ ...\\ ,\\ 0,\\ 1,\\ k-2k, k+1, ... , 0, 1, k−2，如上例中 3 4 5 0 13\\ 4\\ 5\\ 0\\ 13 4 5 0 1 这个函数称之为 g(n−1,m)g(n-1,m)g(n−1,m)，它的最终结果与 f(n,m)f(n,m)f(n,m) 是相同的。 二. 找到映射函数 现在想办法找到 g(n−1,m)g(n-1,m)g(n−1,m) 与 f(n−1,m)f(n-1, m)f(n−1,m) 的对应关系，即 3→04→15→20→31→43 \\rightarrow 0 \\\\ 4 \\rightarrow 1 \\\\ 5 \\rightarrow 2 \\\\ 0 \\rightarrow 3 \\\\ 1 \\rightarrow 4 \\\\ 3→04→15→20→31→4 映射函数为 mapping(x)={x−kx=[k..n−1]x+n−kx=[0..k−2]mapping(x) = \\begin{cases} x-k &amp; x=[k..n-1] \\\\ x+n-k &amp; x=[0..k-2] \\end{cases} mapping(x)={x−kx+n−k​x=[k..n−1]x=[0..k−2]​ 等价于下面函数 mapping(x)=(x+n−k)%nmapping(x) = (x + n - k)\\%{n} mapping(x)=(x+n−k)%n 代入测试一下 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→43 \\rightarrow (3+6-3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+6-3)\\%6 \\rightarrow 1 \\\\ 5 \\rightarrow (5+6-3)\\%6 \\rightarrow 2 \\\\ 0 \\rightarrow (0+6-3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+6-3)\\%6 \\rightarrow 4 \\\\ 3→(3+6−3)%6→04→(4+6−3)%6→15→(5+6−3)%6→20→(0+6−3)%6→31→(1+6−3)%6→4 综上有 f(n−1,m)=mapping(g(n−1,m))f(n-1,m) = mapping(g(n-1,m)) f(n−1,m)=mapping(g(n−1,m)) 三. 求逆映射函数 映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x mapping−1(x)=(x+k)%nmapping^{-1}(x) = (x + k)\\%n mapping−1(x)=(x+k)%n 代入测试一下 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→10 \\rightarrow (0+3)\\%6 \\rightarrow 3 \\\\ 1 \\rightarrow (1+3)\\%6 \\rightarrow 4 \\\\ 2 \\rightarrow (2+3)\\%6 \\rightarrow 5 \\\\ 3 \\rightarrow (3+3)\\%6 \\rightarrow 0 \\\\ 4 \\rightarrow (4+3)\\%6 \\rightarrow 1 \\\\ 0→(0+3)%6→31→(1+3)%6→42→(2+3)%6→53→(3+3)%6→04→(4+3)%6→1 因此可以求得 g(n−1,m)=mapping−1(f(n−1,m))g(n-1,m) = mapping^{-1}(f(n-1,m)) g(n−1,m)=mapping−1(f(n−1,m)) 四. 递推式 代入推导 f(n,m)= g(n−1,m)= mapping−1(f(n−1,m))= (f(n−1,m)+k)%n= (f(n−1,m)+m%n)%n= (f(n−1,m)+m)%n\\begin{aligned} f(n,m) = \\ &amp; g(n-1,m) \\\\ = \\ &amp; mapping^{-1}(f(n-1,m)) \\\\ = \\ &amp; (f(n-1,m) + k) \\% n \\\\ = \\ &amp; (f(n-1,m) + m\\%n) \\% n \\\\ = \\ &amp; (f(n-1,m) + m) \\% n \\\\ \\end{aligned} f(n,m)= = = = = ​g(n−1,m)mapping−1(f(n−1,m))(f(n−1,m)+k)%n(f(n−1,m)+m%n)%n(f(n−1,m)+m)%n​ 最后一步化简是利用了模运算法则 (a+b)%n=(a%n+b%n)%n(a+b)\\%n = (a\\%n + b\\%n) \\%n(a+b)%n=(a%n+b%n)%n 例如 (6+6)%5=2=(6+6%5)%5(6+6)\\%5 = 2 = (6+6\\%5)\\%5(6+6)%5=2=(6+6%5)%5 (6+5)%5=1=(6+5%5)%5(6+5)\\%5 = 1 = (6+5\\%5)\\%5(6+5)%5=1=(6+5%5)%5 (6+4)%5=0=(6+4%5)%5(6+4)\\%5 = 0 = (6+4\\%5)\\%5(6+4)%5=0=(6+4%5)%5 最终递推式 f(n,m)={(f(n−1,m)+m)%nn&gt;10n=1f(n,m) = \\begin{cases} (f(n-1,m) + m) \\% n &amp; n&gt;1\\\\ 0 &amp; n = 1 \\end{cases} f(n,m)={(f(n−1,m)+m)%n0​n&gt;1n=1​ 3) 多路递归 Multi Recursion E01. 斐波那契数列 之前的例子是每个递归函数只包含一个自身的调用，这称之为 single recursion 如果每个递归函数例包含多个自身调用，称之为 multi recursion 递推关系 f(n)={0n=01n=1f(n−1)+f(n−2)n&gt;1f(n) = \\begin{cases} 0 &amp; n=0 \\\\ 1 &amp; n=1 \\\\ f(n-1) + f(n-2) &amp; n&gt;1 \\end{cases} f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n&gt;1​ 下面的表格列出了数列的前几项 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 0 1 1 2 3 5 8 13 21 34 55 89 144 233 实现 123456789public static int f(int n) &#123; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; return f(n - 1) + f(n - 2);&#125; 执行流程 绿色代表正在执行（对应递），灰色代表执行结束（对应归） 递不到头，不能归，对应着深度优先搜索 时间复杂度 递归的次数也符合斐波那契规律，2∗f(n+1)−12 * f(n+1)-12∗f(n+1)−1 时间复杂度推导过程 斐波那契通项公式 f(n)=15∗(1+52n−1−52n)f(n) = \\frac{1}{\\sqrt{5}}*({\\frac{1+\\sqrt{5}}{2}}^n - {\\frac{1-\\sqrt{5}}{2}}^n)f(n)=5​1​∗(21+5​​n−21−5​​n) 简化为：f(n)=12.236∗(1.618n−(−0.618)n)f(n) = \\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)f(n)=2.2361​∗(1.618n−(−0.618)n) 带入递归次数公式 2∗12.236∗(1.618n+1−(−0.618)n+1)−12*\\frac{1}{2.236}*({1.618}^{n+1} - {(-0.618)}^{n+1})-12∗2.2361​∗(1.618n+1−(−0.618)n+1)−1 时间复杂度为 Θ(1.618n)\\Theta(1.618^n)Θ(1.618n) 更多 Fibonacci 参考[8][9][^10] 以上时间复杂度分析，未考虑大数相加的因素 变体1 - 兔子问题 第一个月，有一对未成熟的兔子（黑色，注意图中个头较小） 第二个月，它们成熟 第三个月，它们能产下一对新的小兔子（蓝色） 所有兔子遵循相同规律，求第 nnn 个月的兔子数 分析 兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 f(n)f(n)f(n) f(n)f(n)f(n) = 上个月兔子数 + 新生的小兔子数 而【新生的小兔子数】实际就是【上个月成熟的兔子数】 因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】 上个月兔子数，即 f(n−1)f(n-1)f(n−1) 上上个月的兔子数，即 f(n−2)f(n-2)f(n−2) 因此本质还是斐波那契数列，只是从其第一项开始 变体2 - 青蛙爬楼梯 楼梯有 nnn 阶 青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶 只能向上跳，问有多少种跳法 分析 n 跳法 规律 1 (1) 暂时看不出 2 (1,1) (2) 暂时看不出 3 (1,1,1) (1,2) (2,1) 暂时看不出 4 (1,1,1,1) (1,2,1) (2,1,1)(1,1,2) (2,2) 最后一跳，跳一个台阶的，基于f(3)最后一跳，跳两个台阶的，基于f(2) 5 … … 因此本质上还是斐波那契数列，只是从其第二项开始 E02. 汉诺塔（多路递归） Tower of Hanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着 64 片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定 一次只能移动一个圆盘 小圆盘上不能放大圆盘 下面的动图演示了4片圆盘的移动方法 E03. 杨辉三角 优化1 在multiple recursion过程中，有很多 ，因此很多递归调用是重复的，用 memoization 来进行优化： 123456789101112131415161718192021222324public static void print1(int n) &#123; int[][] triangle = new int[n][]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 triangle[i] = new int[i + 1]; for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, element1(triangle, i, j)); &#125; System.out.println(); &#125;&#125;public static int element1(int[][] triangle, int i, int j) &#123; if (triangle[i][j] &gt; 0) &#123; return triangle[i][j]; &#125; if (j == 0 || i == j) &#123; triangle[i][j] = 1; return triangle[i][j]; &#125; triangle[i][j] = element1(triangle, i - 1, j - 1) + element1(triangle, i - 1, j); return triangle[i][j];&#125; 将数组作为递归函数内可以访问的遍历，如果 triangle[i][j]triangle[i][j]triangle[i][j] 已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了 优化2 123456789101112131415161718192021public static void print2(int n) &#123; int[] row = new int[n]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 createRow(row, i); for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, row[j]); &#125; System.out.println(); &#125;&#125;private static void createRow(int[] row, int i) &#123; if (i == 0) &#123; row[0] = 1; return; &#125; for (int j = i; j &gt; 0; j--) &#123; row[j] = row[j - 1] + row[j]; &#125;&#125; 4) 递归优化-记忆法 Memoization 记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码 1234567891011121314151617public static void main(String[] args) &#123; int n = 13; int[] cache = new int[n + 1]; Arrays.fill(cache, -1); cache[0] = 0; cache[1] = 1; System.out.println(f(cache, n));&#125;public static int f(int[] cache, int n) &#123; if (cache[n] != -1) &#123; return cache[n]; &#125; cache[n] = f(cache, n - 1) + f(cache, n - 2); return cache[n];&#125; 优化后的图示，只要结果被缓存，就不会执行其子问题 改进后的时间复杂度为 O(n)O(n)O(n) 注意 记忆法是动态规划的一种情况，强调的是自顶向下的解决 记忆法的本质是空间换时间 5) 递归优化-尾递归 爆栈 每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等 方法调用占用的内存需要等到方法结束时才会释放 而递归调用过程中，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了 尾调用 如果函数的最后一步是调用一个函数，那么称为尾调用 尾递归 尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数 尾递归避免爆栈 Java目前还不支持，但可以在IDEA插件安装 Scala 12345object Main &#123; def main(args: Array[String]): Unit = &#123; println(&quot;Hello Scala&quot;) &#125;&#125; Scala中，java 中的类都可以拿来重用 类型是放在变量后面的 Unit 表示无返回值，类似于 void 不需要以分号作为结尾，当然加上也对 Scala 最后一行代码若作为返回值，可以省略 return 代码如下 1234567@tailrecdef sum(n: Long, accumulator: Long): Long = &#123; if (n == 1) &#123; return 1 + accumulator &#125; return sum(n - 1, n + accumulator)&#125; accumulator 作为累加器 @tailrec 注解是 scala 提供的，用来检查方法是否符合尾递归 本质上，尾递归优化是将函数的递归调用，变成了函数的循环调用，可以在java中改为循坏避免爆栈问题 6) 递归时间复杂度-Master theorem 若有递归式 T(n)=aT(nb)+f(n)T(n) = aT(\\frac{n}{b}) + f(n) T(n)=aT(bn​)+f(n) 其中 T(n)T(n)T(n) 是问题的运行时间，nnn 是数据规模 aaa 是子问题个数 T(nb)T(\\frac{n}{b})T(bn​) 是子问题运行时间，每个子问题被拆成原问题数据规模的 nb\\frac{n}{b}bn​ f(n)f(n)f(n) 是除递归外执行的计算 令 x=log⁡bax = \\log_{b}{a}x=logb​a，即 x=log⁡子问题缩小倍数子问题个数x = \\log_{子问题缩小倍数}{子问题个数}x=log子问题缩小倍数​子问题个数 那么 T(n)={Θ(nx)f(n)=O(nc)并且c&lt;xΘ(nxlog⁡n)f(n)=Θ(nx)Θ(nc)f(n)=Ω(nc)并且c&gt;xT(n) = \\begin{cases} \\Theta(n^x) &amp; f(n) = O(n^c) 并且 c \\lt x\\\\ \\Theta(n^x\\log{n}) &amp; f(n) = \\Theta(n^x)\\\\ \\Theta(n^c) &amp; f(n) = \\Omega(n^c) 并且 c \\gt x \\end{cases} T(n)=⎩⎨⎧​Θ(nx)Θ(nxlogn)Θ(nc)​f(n)=O(nc)并且c&lt;xf(n)=Θ(nx)f(n)=Ω(nc)并且c&gt;x​ 例1 T(n)=2T(n2)+n4T(n) = 2T(\\frac{n}{2}) + n^4T(n)=2T(2n​)+n4 此时 x=1&lt;4x = 1 &lt; 4x=1&lt;4，由后者决定整个时间复杂度 Θ(n4)\\Theta(n^4)Θ(n4) 如果觉得对数不好算，可以换为求【bbb 的几次方能等于 aaa】 例2 T(n)=T(7n10)+nT(n) = T(\\frac{7n}{10}) + nT(n)=T(107n​)+n a=1,b=107,x=0,c=1a=1, b=\\frac{10}{7}, x=0, c=1a=1,b=710​,x=0,c=1 此时 x=0&lt;1x = 0 &lt; 1x=0&lt;1，由后者决定整个时间复杂度 Θ(n)\\Theta(n)Θ(n) 例3 T(n)=16T(n4)+n2T(n) = 16T(\\frac{n}{4}) + n^2T(n)=16T(4n​)+n2 a=16,b=4,x=2,c=2a=16, b=4, x=2, c=2a=16,b=4,x=2,c=2 此时 x=2=cx=2 = cx=2=c，时间复杂度 Θ(n2log⁡n)\\Theta(n^2 \\log{n})Θ(n2logn) 例4 T(n)=7T(n3)+n2T(n)=7T(\\frac{n}{3}) + n^2T(n)=7T(3n​)+n2 a=7,b=3,x=1.?,c=2a=7, b=3, x=1.?, c=2a=7,b=3,x=1.?,c=2 此时 x=log⁡37&lt;2x = \\log_{3}{7} &lt; 2x=log3​7&lt;2，由后者决定整个时间复杂度 Θ(n2)\\Theta(n^2)Θ(n2) 例5 T(n)=7T(n2)+n2T(n) = 7T(\\frac{n}{2}) + n^2T(n)=7T(2n​)+n2 a=7,b=2,x=2.?,c=2a=7, b=2, x=2.?, c=2a=7,b=2,x=2.?,c=2 此时 x=log27&gt;2x = log_2{7} &gt; 2x=log2​7&gt;2，由前者决定整个时间复杂度 Θ(nlog⁡27)\\Theta(n^{\\log_2{7}})Θ(nlog2​7) 例6 T(n)=2T(n4)+nT(n) = 2T(\\frac{n}{4}) + \\sqrt{n}T(n)=2T(4n​)+n​ a=2,b=4,x=0.5,c=0.5a=2, b=4, x = 0.5, c=0.5a=2,b=4,x=0.5,c=0.5 此时 x=0.5=cx = 0.5 = cx=0.5=c，时间复杂度 Θ(nlog⁡n)\\Theta(\\sqrt{n}\\log{n})Θ(n​logn) 7) 递归时间复杂度-展开求解 像下面的递归式，都不能用主定理求解 例1 - 递归求和 123456long sum(long n) &#123; if (n == 1) &#123; return 1; &#125; return n + sum(n - 1);&#125; T(n)=T(n−1)+cT(n) = T(n-1) + cT(n)=T(n−1)+c，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+c+cT(n) = T(n-2) + c + cT(n)=T(n−2)+c+c T(n)=T(n−3)+c+c+cT(n) = T(n-3) + c + c + cT(n)=T(n−3)+c+c+c … T(n)=T(n−(n−1))+(n−1)cT(n) = T(n-(n-1)) + (n-1)cT(n)=T(n−(n−1))+(n−1)c 其中 T(n−(n−1))T(n-(n-1))T(n−(n−1)) 即 T(1)T(1)T(1) 带入求得 T(n)=c+(n−1)c=ncT(n) = c + (n-1)c = ncT(n)=c+(n−1)c=nc 时间复杂度为 O(n)O(n)O(n) 例2 - 递归冒泡排序 1234567891011void bubble(int[] a, int high) &#123; if(0 == high) &#123; return; &#125; for (int i = 0; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); &#125; &#125; bubble(a, high - 1);&#125; T(n)=T(n−1)+nT(n) = T(n-1) + nT(n)=T(n−1)+n，T(1)=cT(1) = cT(1)=c 下面为展开过程 T(n)=T(n−2)+(n−1)+nT(n) = T(n-2) + (n-1) + nT(n)=T(n−2)+(n−1)+n T(n)=T(n−3)+(n−2)+(n−1)+nT(n) = T(n-3) + (n-2) + (n-1) + nT(n)=T(n−3)+(n−2)+(n−1)+n … T(n)=T(1)+2+...+n=T(1)+(n−1)2+n2=c+n22+n2−1T(n) = T(1) + 2 + ... + n = T(1) + (n-1)\\frac{2+n}{2} = c + \\frac{n^2}{2} + \\frac{n}{2} -1T(n)=T(1)+2+...+n=T(1)+(n−1)22+n​=c+2n2​+2n​−1 时间复杂度 O(n2)O(n^2)O(n2) 注： 等差数列求和为 个数∗∣首项−末项∣2个数*\\frac{\\vert首项-末项\\vert}{2}个数∗2∣首项−末项∣​ 可用该站进行公式推导：https://www.wolframalpha.com/","tags":["数据结构"],"categories":["学习笔记"]},{"title":"b","path":"/2023/11/24/b/","content":"还行 不是 啊 这 不是吧 哦哦"},{"title":"a","path":"/2023/11/23/a/","content":"我是一只小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的","tags":["Java"],"categories":["技术随笔"]},{"title":"Redis-基础","path":"/2023/11/08/Redis-基础/","content":"1.Redis简单介绍 Redis是一种键值型的NoSql数据库，这里有两个关键字： 键值型 NoSql 其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json。 而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。 对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。 2.初识Redis 2.1.认识NoSQL NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 2.1.1.结构化与非结构化 传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。 而NoSql则对数据库格式没有严格约束，往往形式松散，自由。 可以是键值型，也可以是文档型，甚至可以是图格式。 2.1.2.关联和非关联 传统数据库的表与表之间往往存在关联，例如外键： 而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合： 123456789101112131415161718&#123; id: 1, name: &quot;张三&quot;, orders: [ &#123; id: 1, item: &#123; id: 10, title: &quot;荣耀6&quot;, price: 4999 &#125; &#125;, &#123; id: 2, item: &#123; id: 20, title: &quot;小米11&quot;, price: 3999 &#125; &#125; ]&#125; 此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。 2.1.3.查询方式 传统关系型数据库会基于Sql语句做查询，语法有统一标准； 而不同的非关系数据库查询语法差异极大，五花八门各种各样。 2.1.4.事务 传统关系型数据库能满足事务ACID的原则。 而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。 2.1.5.总结 除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下： 存储方式 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些 扩展性 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦 2.2.认识Redis Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存.IO多路复用.良好的编码）。 支持数据持久化 支持主从集群.分片集群 支持多语言客户端 Redis的官方网站地址：https://redis.io/ 3.Redis常见命令 3.1 Redis数据结构介绍 Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令，也可以执行该命令进入容器执行命令。 1docker exec -it &lt;container_name_or_id&gt; redis-cli 3.2 Redis 通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL(Time To Live，生存时间)：查看一个KEY的剩余有效期 通过help [command] 可以查看一个命令的具体用法。 代码如下 KEYS 123456789127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt; 提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 DEL 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1 #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;\t#只剩下一个了127.0.0.1:6379&gt; 提示：在拷贝代码的时候，只需要拷贝对应的命令 EXISTS 123456789101112127.0.0.1:6379&gt; help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE 提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除 1234567891011127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1 # ttl的返回值就是-1 3.3 Redis命令-String命令 String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 String的常见命令有： SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（必须指定增长步长） SETNX(set not exit)：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX(set key expire time)：添加一个String类型的键值对，并且指定有效期 提示：以上命令除了INCRBYFLOAT 都是常用命令，且有一些组合命令如SETNX,SETEX. SET 和GET: 如果key不存在则是新增，如果存在则是修改 1234567891011127.0.0.1:6379&gt; set name Rose //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot; MSET和MGET 123456789127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot; //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot; INCR和INCRBY和DECY 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11 127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值 127.0.0.1:6379&gt; incrby age 2(integer) 15 127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14 127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12 127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11 127.0.0.1:6379&gt; get age &quot;11&quot; SETNX 1234567891011121314151617127.0.0.1:6379&gt; help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string127.0.0.1:6379&gt; set name Jack //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot; SETEX 12345678127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7 3.4 Redis命令-Key的层级结构 Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:'隔开，格式如下： **项目名：业务名：类型：id** 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于文件夹的结构，更加方便Redis获取数据。 3.5 Redis命令-Hash命令 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。 Hash类型的常见命令 HSET key field value：添加或者修改hash类型key的field的值 HGET key field：获取一个hash类型key的field的值 HMSET：批量获取多个hash类型key的field的值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有的field HVALS：获取一个hash类型的key中的所有的field的值 HINCRBY:让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 提示：哈希结构也是实际开发中常用的命令 HSET和HGET 12345678910127.0.0.1:6379&gt; HSET user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET user:3 age&quot;17&quot; HMSET和HMGET 12345678127.0.0.1:6379&gt; HMSET user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HGETALL 1234567127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot; HKEYS和HVALS 12345678127.0.0.1:6379&gt; HKEYS user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HINCRBY 12345678127.0.0.1:6379&gt; HINCRBY user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY user:4 age -2(integer) 20 HSETNX 12345678910111213141516127.0.0.1:6379&gt; HSETNX user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot; 3.6 Redis命令-List命令 Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element … ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素，start表示起始索引，end表示结束索引 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil LPUSH和RPUSH 1234127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6 LPOP和RPOP 1234127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot; LRANGE 123127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot; 3.7 Redis命令-Set命令 Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set类型的常见命令 SADD key member … ：向set中添加一个或多个元素 SREM key member … : 移除set中的指定元素 SCARD key： 返回set中元素的个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2 … ：求key1与key2的交集 SDIFF key1 key2 … ：求key1与key2的差集 SUNION key1 key2 …：求key1和key2的并集 例如两个集合：s1和s2: 求交集：SINTER s1 s2 求s1与s2的不同：SDIFF s1 s2 具体命令 1234567891011121314151617127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1 127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0 127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1 127.0.0.1:6379&gt; SCARD s1(integer) 2 3.8 Redis命令-SortedSet类型 Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member : 获取sorted set中的指定元素的score值 ZRANK key member：获取sorted set 中的指定元素的排名 ZCARD key：获取sorted set中的元素个数 ZCOUNT key min max：统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max：按照score排序后，获取指定排名范围内的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF.ZINTER.ZUNION：求差集.交集.并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 4.Redis的Java客户端-Jedis 在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。 4.1 Jedis快速入门 入门案例详细步骤 案例分析： 0）创建工程： 1）引入依赖： 12345678910111213&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）建立连接 新建一个单元测试类，内容如下： 123456789101112private Jedis jedis;@BeforeEachvoid setUp() &#123; // 1.建立连接 // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(&quot;123321&quot;); // 3.选择库 jedis.select(0);&#125; 3）测试： 1234567891011121314151617181920@Testvoid testString() &#123; // 存入数据 String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123; // 插入hash数据 jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;); jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;); // 获取 Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;); System.out.println(map);&#125;} 4）释放资源 123456@AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125;} 4.2 Jedis连接池 Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如tomcat中的线程池，这些都是池化思想的体现。 4.2.1.创建Jedis的连接池 1234567891011121314151617181920public class JedisConnectionFacotry &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;} 代码说明： 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，可以使用工厂，去降低耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3）最后提供返回连接池中连接的方法. 4.2.2.改造原始代码 代码说明: 1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。 ，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。 2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。 123456789101112131415 @BeforeEach void setUp()&#123; //建立连接 /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); &#125;@AfterEach void tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;} 5.Redis的Java客户端-SpringDataRedis SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 5.1.快速入门 SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 5.1.1.导入pom坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Jackson依赖，不引入springmvc的情况下，设置序列化器需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;} 5.1.2 .配置文件 12345678910spring: redis: host: 192.168.150.101 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间} 5.1.3.测试代码 123456789101112131415@SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test void testString() &#123; // 写入一条String数据 redisTemplate.opsForValue().set(&quot;name&quot;, &quot;那个谁&quot;); // 获取string数据 Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125;&#125;} 提示：SpringDataRedis使用起来非常简单，记住如下几个步骤即可 SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis信息 注入RedisTemplate 5.2 .数据序列化器 RedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125;} 这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图： 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 5.3 StringRedisTemplate 尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图： 为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass RedisStringTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() &#123; // 写入一条String数据 stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125; private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException &#123; // 创建对象 User user = new User(&quot;虎哥&quot;, 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(&quot;user1 = &quot; + user1); &#125;&#125;} 此时再来看存储的数据，就会发现那个class数据已经不在了，节约了我们的空间。 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象","tags":["Redis"],"categories":["学习笔记"]},{"title":"MySQL-基础(2)","path":"/2023/05/25/MySQL-基础(2)/","content":"函数 概念 函数一般是指一段可以直接被另一段程序调用的程序或代码 字符串函数 MySQL常用函数如下： 函数 功能 CONCAT(S1,S2,…Sn) 字符串拼接，将S1,S2,…Sn拼成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str，n，pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str，n，pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str，strart，len) 返回从字符串str从start位置起的len个长度的字符串 123456789101112SELECT CONCAT(&#x27;hello&#x27;,&#x27;masql&#x27;,&#x27;!&#x27;); # hellomasql!SELECT UPPER(&#x27;hleeo&#x27;); # HLEEOSELECT LOWER(&#x27;HELLO&#x27;); # helloSELECT LPAD(&#x27;HELLO&#x27;,9,&#x27;--&#x27;); # ----HELLOSELECT RPAD(&#x27;HELLO&#x27;,9,&#x27;--&#x27;); # HELLO----SELECT TRIM(&#x27; hello world &#x27;); # hello worldSELECT SUBSTRING(&#x27; hello world &#x27;,1,10); 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(X) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 12345678910111213141516-- 数值函数SELECT RAND(); SELECT MOD(5,2); # 1SELECT ROUND(3.1415926,5); # 3.14159SELECT CEIL(1.000001);\t# 2SELECT FLOOR(1.9999999); # 1-- 通过函数，生成一个六位数的随机验证码-- 先生成一个随机数乘以1000000-- 再对其进行四舍五入保留0位小数-- 最后将其进行填充，以达到六位数SELECT LPAD(ROUND(RAND() * 1000000,0),6,&#x27;0&#x27;); 日期函数 常见日期函数如下 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date，INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1，date2) 返回起始时间data1和结束时间date2之间的天数 123456789101112131415161718-- 时间函数SELECT CURDATE(); -- 2023-03-23SELECT CURTIME(); -- 21:34:42SELECT NOW(); -- 2023-03-23 21:34:17SELECT YEAR(NOW()); -- 2023SELECT MONTH(NOW()); -- 3SELECT DAY(NOW()); -- 23SELECT DATE_ADD(NOW(),INTERVAL 70 YEAR); -- 2093-03-23 21:37:21-- 前面的时间减去后面的时间SELECT DATEDIFF(CURDATE(),&#x27;2003-12-27&#x27;); -- 7026SELECT DATEDIFF(&#x27;2003-12-27&#x27;,CURDATE()); -- -7026 流程控制函数 流程函数也是常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句效率 函数 功能 IF(value，t，f) 如果value为true，则返回t，否则返回f IFNULL(value1，value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [val1] THEN [res1] …ELSE [default] END 如果val1为true，返回rest1，…否则返回fedault默认值 CASE [expr] WHEN [val1] THEN [res1] …ELSE [default] END 如果expr的值等于val1，返回res1，…否则返回default默认值 字段演示 表达式演示 约束 概念 约束是作用于表中列上得规则，用于限制加入表的数据； 约束的存在保证了数据库中数据的正确性、有效性和完整性。 约束的分类 名称 描述 关键字 非空约束 保证所有数据不为null NUT NULL 唯一约束 保证列中所有数据各不相同 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 检查约束 保证列中所有的值满足某一条件 CHECK 默认约束 保存数据时，未指定值则采用默认值 DEFAULT 外键约束 外键用来让两个表的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 额外的，主键自动增长：AUTO_INCREMENT（使用条件：当前列是数字类型并且唯一约束） 代码演示 12345678CREATE TABLE person(id INT PRIMARY KEY AUTO_INCREMENT, -- id，主键且自增长name VARCHAR(20) NOT NULL UNIQUE, -- 姓名，非空且唯一age INT CHECK(age &lt;100 AND age &gt; 0), -- 年龄，大于0小于100sex VARCHAR(5) NOT NULL , -- 性别，不为空address VARCHAR(5) NOT NULL, -- 住址，不为空score DOUBLE(5,2) DEFAULT 0 NOT NULL -- 成绩默认为0,不为空); 外键约束 语法 外键的创建，需要满足以下四个条件，否则会被MySQL数据库拒绝： 1、创建外键的表和列存在 2、组成外键的列存在索引 3、外键字段和关联字段，数据类型必须一致 删除/更新行为 行为 说明 NO ACTION （默认行为） 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致) RESTRICT（默认行为） 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致) CASCADE 当在父表中删除/更新对应记录时，首先应该检查是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 SET NULL 当在父表中删除对应记录时，首先应该检查是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许null)。 SET DEFAULT 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)。 12-- CASCADEALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY 从表字段名 REFERANCE 主表(字段名) ON UPDATE 行为 ON DELETE 行为; 添加约束 123456789-- 创建表时添加外键约束CREATE TABLE 表名(\t列名 数据类型, …… [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名));-- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表(主表列名); 删除约束 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 实例演示 1234567891011121314151617181920-- 部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT,\tdep_name varchar(10));-- 员工表CREATE TABLE emp( id INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(10),\tage int,\tdep_id int, -- 添加外键 dep-id,关联dept表的id主键\tCONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id));-- 注：当需要添加外键时，应该先有主表再有从表，信息的添加也是。-- 创建完表后添加外键ALTER TABLE emp ADD CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id); 逆向表到模型演示 12-- 删除外键ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept; 逆向表到模型演示 多表查询 简介 笛卡尔积：取A,B组合所有情况 多表查询：从多张表查询数据 多表关系介绍 一对一 - 如 用户 与 用户详情 的关系 - 一对一对用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 - 在任意一方面加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE 一对多 - 如 部门 与 员工 的关系 - 个部门对应多个员工，一个员工对应一个部门 - 在多的一方建立外键，指向一的一方的主键 多对多 - 如 学生 与 课程 的关系 - 一个学生可以选修多门课程，一门课程也可以供多个学生选择 - 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 连接查询 内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 外连接：查询所有的数据时，就一定会用到外连接。 左外连接：相当于查询A（左）表所有数据和交集部分数据 右外连接：相当于查询B（右）表所有数据和交集部分数据 满外连接：满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 自连接：当前表与自身的连接查询，自连接必须使用表别名 自连接查询，可以是内连接，也可以是外连接 联合查询-UNION , UNION ALL 把多次查询的结果合并起来，形成一个新的查询结果集 子查询 概念：查询中嵌套查询，称嵌套查询为子查询 子查询根据查询结果不同，作用不同，分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 子查询的外部语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个 根据子查询位置，分为：WHERE之后，FROM之后，SELECT之后。 内连接 12345-- 隐式内连接:没有JOIN关键字，条件使用WHERE指定SELECT 字段列表 FROM 表1，表2，…… WHERE 条件;-- 显示内连接:使用INNER JOIN ... ON语句, 可以省略INNERSELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 表连接条件 WHERE 查询条件; 外连接 12345678-- 左外连接:使用LEFT OUTER JOIN ... ON，OUTER可以省略SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 表连接条件 WHERE 查询条件;-- 右外连接SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 表连接条件 WHERE 查询条件;-- 其两者本质区别是表名的位置所在，一般情况下使用左外连接 自连接 1SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件…… ; 实例演示 连接关系图 联合查询(UNION) 123SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2 UNION 操作符返回两个查询的结果集的并集，去除重复记录。 UNION ALL 操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。 结论：如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。 实例演示 子查询 查询语法 12345678-- 单行单列：作为条件值，使用= != &gt; &lt; 等进行条件判断SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询);-- 多行单列：作为条件值，使用IN等关键字进行条件判断SELECT 字段列表 FROM 表 WHERE 字段名 in (子查询);-- 多行多列：作为虚拟表SELECT 字段列表 FROM (子查询) WHERE 条件; 标量子查询 子查询的结果返回单个值（数字，字符串，日期等），最简单的形式，称为标量子查询 常用操作符： = 、 &lt;&gt; 、 &gt; 、 &gt;= 、 &lt; 、 &lt;= 实例演示 列子查询 子查询的返回结果是一列（可以是多行），这种子查询称为列子查询。 常用操作符： IN 、 NOT IN 、 ANY 、 SOME 、 ALL 操作符 描述 IN 在指定的集合范围内多选一 NOT IN 不在指定的集合范围内 ANY 列子查询返回列表中，有任意一个满足即可 SOME 与ANY等同 ALL 子查询返回列表的所有值都必须满足 实例演示 行子查询 子查询返回的结果是一行（可以是多行），称为行子查询。 常用操作符： = 、 &lt;&gt; 、 IN 、 NOT IN 实例演示 表子查询 子查询返回的结果是多行多列，这种子查询称为表子查询。 常用操作符：IN 实例演示 查询总实例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127-- 部门表CREATE TABLE dept1(\tid INT PRIMARY KEY, -- 部门id\tdname VARCHAR(50), -- 部门名称\tloc VARCHAR(50) -- 部门所在地);-- 职务表，职务名称，职务描述CREATE TABLE job1(\tid INT PRIMARY KEY,\tjname VARCHAR(20),\tdescription VARCHAR(50));-- 员工表CREATE TABLE emp(\tid INT PRIMARY KEY, -- 员工id\tename VARCHAR(50), -- 员工姓名\tjob_id INT, -- 职务id\tmgr INT, -- 上级领导\tjoindata DATE, -- 入职日期\tsalary DECIMAL(7,2), -- 工资\tbonus DECIMAL(7,2), -- 奖金\tdept_id INT, -- 所在部门编号\tCONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job1(id),\tCONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept1(id)\t);\t-- 工资等级表CREATE TABLE salaryGrade( grade INT PRIMARY KEY, -- 级别\tlowSalary INT, -- 最低工资\theiSalary INT -- 最高工资\t);\t-- 添加四个部门INSERT INTO dept1(id,dname,loc) VALUES(10,&#x27;教研部&#x27;,&#x27;北京&#x27;),(20,&#x27;学工部&#x27;,&#x27;上海&#x27;),(30,&#x27;销售部&#x27;,&#x27;广州&#x27;),(40,&#x27;财务部&#x27;,&#x27;深圳&#x27;);-- 添加四个职务INSERT INTO job1 (id,jname,description) VALUES(1,&#x27;董事长&#x27;,&#x27;管理公司，接单&#x27;),(2,&#x27;经理&#x27;,&#x27;管理部门员工&#x27;),(3,&#x27;销售&#x27;,&#x27;向客人推销产品&#x27;),(4,&#x27;文员&#x27;,&#x27;使用办公软件&#x27;);-- 添加四个员工INSERT INTO emp(id,ename,job_id,mgr,joindata,salary,bonus,dept_id)VALUES(1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20),(1002,&#x27;猪八戒&#x27;,3,1006,&#x27;2001-1-5&#x27;,&#x27;3000.00&#x27;,NULL,10),(1003,&#x27;沙和尚&#x27;,2,1007,&#x27;2003-12-27&#x27;,&#x27;9000.00&#x27;,NULL,30),(1004,&#x27;唐僧&#x27;,1,1009,&#x27;2015-8-7&#x27;,&#x27;6000.00&#x27;,NULL,40);-- 添加五个工资等级INSERT INTO salaryGrade(grade,lowSalary,heiSalary)VALUES(1,3000,12000),(2,12000,16000),(3,16000,20000);-- 1、查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/*分析：\t1、员工编号，员工姓名，工资，信息在emp员工表中\t2、职务名称，职务描述，信息在job职务表中，\t3、job 和 emp 是 一对多的关系 emp.job_id = job.id*/-- 隐式内连接SELECT emp.id,ename,salary,jname,description FROM emp,job1 WHERE emp.job_id = job1.id;-- 显式内连接SELECT emp.id,ename,salary,jname,description FROM job1 INNER JOIN emp ON emp.job_id = job1.id;-- 2、查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置/*分析：\t1、员工编号，员工姓名，工资在emp表中\t2、职务名称，职务描述，在job1表中\t3、部门名称，部门位置，在dept1表中\t4、emp和dept1为一对多，emp和job1也为一对多*/-- 隐式内链接SELECT emp.id,emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc FROM emp,dept1,job1 WHERE dept1.id = emp.dept_id AND emp.job_id = job1.id; -- 显式内连接SELECT emp.id,emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc FROM emp INNER JOIN dept1 ON dept1.id = emp.dept_id INNER JOIN job1 ON emp.job_id = job1.id; -- 3、查询员工姓名，工资，工资等级/*分析：\t1、员工姓名在emp中，工资，\t2、工资等级在salarygrade中\t3、emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary*/-- 左外连接SELECT emp.ename,emp.salary,salarygrade.grade FROM emp LEFT OUTER JOIN salarygrade ON emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary;-- 4、查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级/*分析：\t1、员工姓名，工资，在emp\t2、职务名称，职务描述，在job1\t3、部门名称，部门位置，在dept1\t4、工资等级，在salarygrade*/-- 隐式内连接SELECT emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc,salarygrade.grade FROM emp,salarygrade,dept1,job1 WHERE emp.dept_id = dept1.id AND emp.job_id = job1.id AND emp.salary &gt;= salarygrade.lowSalary AND emp.salary &lt;= salarygrade.heiSalary;-- 显式内连接SELECT emp.ename,emp.salary,job1.jname,job1.description,dept1.dname,dept1.loc,salarygrade.grade FROM emp INNER JOIN job1 ON emp.job_id = job1.idINNER JOIN dept1 ON emp.dept_id = dept1.idINNER JOIN salarygrade ON emp.salary BETWEEN salarygrade.lowSalary AND salarygrade.heiSalary;-- 5、查询出部门编号，部门名称，部门位置，部门人数/*分析：\t1、部门编号，部门名称，部门位置属于dept\t2、部门人数：在dept1表中，按照dept_id进行分组，然后count（*）统计数量\t3、使用子查询，让部门表和分组后的表进行内连接*/SELECT dept_id,count(*) FROM emp GROUP BY dept_id;SELECT * FROM dept1,(SELECT dept_id,count(*) FROM emp GROUP BY dept_id) tWHERE dept1.id = t.dept_id; 考核错题 123456789-- 5.查询员工 及其 所属领导的名字 SELECT a.`NAME` &#x27;员工&#x27;,b.`NAME` &#x27;领导&#x27; FROM emp a,emp b WHERE a.managerid = b.id;-- 6.查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 -- 左外连接 #2SELECT a.`NAME` &#x27;员工&#x27;,b.`NAME` &#x27;领导&#x27; FROM emp a LEFT JOIN emp b ON a.managerid = b.id; -- 25.查询所有的部门信息, 并统计部门的员工人数select d.id, d.name , ( select count(*) from emp e where e.dept_id = d.id ) &#x27;人数&#x27;from dept d; 事务 简介 数据库的事务(transaction)是一种机制、一个操作序列，包含了一组数据库操作指令。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。 事务十一个不可分割的工作逻辑单元。 语法 123456789-- 开启事务START TRANSACTION;或者 BEGIN;-- 提交事务COMMIT;-- 回滚事务ROLLBACK; MySQL默认事务自动化提交 123456-- 查看事务的默认提交方式SELECT @@AUTOCOMMIT；-- 1 自动提交 0 手动提交-- 修改事务提交方式SET @@AUTOCOMMIT = 0; 代码演示 123456789101112131415161718192021222324252627282930313233DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account(\tid INT PRIMARY KEY auto_increment,\tname VARCHAR(10),\tmoney DOUBLE(10,2));-- 添加数据INSERT INTO account(name,money) VALUES(&#x27;张三&#x27;,1000),(&#x27;李四&#x27;,1000);SELECT * FROM account;UPDATE account SET money = 1000;-- 开始事务BEGIN;-- 转账操作-- 1、李四金额-500UPDATE account SET money = money - 500 WHERE name = &#x27;李四&#x27;;-- 错误。。。-- 2、张三金额+500UPDATE account SET money = money + 500 WHERE name = &#x27;张三&#x27;;-- 提交事务COMMIT；-- 回滚事务ROLLBACK; 事务四大特征(ACID) 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。 也就是说事务前后数据的完整性必须保持一致。 隔离性（Isolation） 隔离性是指一个事务的执行不能有其他事务的干扰，事务的内部操作和使用数据对其他的并发事务是隔离的，互不干扰。 持久性（Durability） 持久性是指一个事务一旦提交，对数据库中数据的改变就是永久性的。此时即使数据库发生故障，修改的数据也不会丢失。接下来其他的操作不会对已经提交了的事务产生影响。 并发事务问题（脏读、不可重复读、幻读) 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 比如在事务 A 修改数据之后提交数据之前，这时另一个事务 B 来读取数据，如果不加控制，事务 B 读取到 A 修改过数据，之后 A 又对数据做了修改再提交，则 B 读到的数据是脏数据，此过程称为脏读。 不可重复读 不可重复读是指在数据库访问中，一个事务范围内多次查询却返回了不同的数据值。这是由于在查询间隔中，其他事务修改并提交而引起的。 比如事务 T1 读取某一数据，事务 T2 读取并修改了该数据，T1 为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 幻读 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 比如事务 A 在按查询条件读取某个范围的记录时，事务 B 又在该范围内插入了新的满足条件的记录，当事务 A 再次按条件查询记录时，会产生新的满足条件的记录。 事务的四个隔离级别 未提交读（Read Uncommitted） 一个事务能够读取到别的事务中没有提交的更新数据。事务中的修改，即使没有提交，其他事务也可以看得到。在这种隔离级别下有可能发生脏读，不可重复读和幻读。 提交读（Read Committed） 事务中的修改只有提交以后才能被其它事务看到。在这种隔离级别下解决了脏读，但是有可能发生不可重复读和幻读。 可重复读（Repeated Read）(默认) 保证了在同一事务中先后执行的多次查询将返回同一结果，看到的每行的记录的结果是一致的，不受其他事务的影响。但是这种级别下有可能发生幻读。 可串行化（Serializable） 不允许事务并发执行，强制事务串行执行。就是在读取的每一行数据上都加上了锁，读写相互都会阻塞，所以效率很低下。这种隔离级别最高，是最安全的，但是性能最低，不会出现脏读，不可重复读，幻读。 注：隔离级别越高，数据安全性越高，但性能越低。 12345-- 查看事务隔离级别SELECT @@TRANSACTION_ISOLATION;-- 设置事务隔离级别SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;","tags":["MySQL"],"categories":["学习笔记"]},{"title":"MySQL-基础(1)","path":"/2023/05/22/MySQL-基础(1)/","content":"数据库相关概念 简介 关系型数据库是建立在关系模型基础上的数据库，即由多张能够相互连接的二维表组成。 MySQL体系结构（存储引擎） 连接层 最上层是一些客户端和连接服务，主要完成类似于连接处理、授权认证、及相关处理方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。 引擎层 存储引擎真正的负责了MySQL中数据的存储和获取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 存储层 主要是将数据存储在文件系统上，并完成存储引擎的交互。 SQL通用语法 可以单行或多行书写，以分号结尾。 不区分大小写，关键字建议大写。 注释： 单行注释：-- 内容 或 #内容 多行注释：/内容/ SQL分类 DDL 数据库定义语言( DATA DEFINITION LANGUAGE ) 用来定义数据对象：数据库、列、表…… DML 数据操作语言( DATA MANIPULATION LANGUAGE ) 用来对数据库中表的增删改 DQL 数据查询语言( DATA QUERY LANGUAGE ) 查询数据库中表的记录（数据） DCL 数据控制语言( DATA CONTROL LANGUAGE ) 定义数据库的访问权限和安全级别，及创建用户 DDL 数据定义语言 简介 DDL 数据库定义语言( DATA DEFINITION LANGUAGE ) 用来定义数据对象：数据库、列、表…… 操作数据库 查询数据库 - 创建数据库 - CREATE DATABASE 库名； - CREATE DATABASE IF NOT EXISTS 库名； 删除数据库 - DROP DATABASE 库名； - DROP DATABASE IF EXISTS 库名； 使用数据库 - USE 库名； 操作表 查询表：查询当前数据库下所有表的名称 - SHOW TABLES; 创建表 - CREATE TABLE 表名( - 字段名1 数据类型1， - 字段名2 数据类型2， - …… - ); 删除表 - DROP TABLE 表名； - DROP TABLE IF EXISTS 表名； 修改表 - 修改表名 - ALTER TABLE 原表名 RENAME TO 新表名； - 添加一列 - ALTER TABLE 表名 ADD 列名 数据类型； - 修改数据类型 - ALTER TABLE 表名 MODIFY 列名 新数据类型； - 修改列名和数据类型 - ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型； - 删除列 - ALTER TABLE 表名 DROP 列名； DML 数据操作语言 简介 DML 数据操作语言( DATA MANIPULATION LANGUAGE ) 用来对数据库中表的增删改 添加数据 插入数据时，指定的字段顺序需要与值的顺序是一一对应的 字符串和日期型数据应该包含在引导中 插入的数据大小，应该在字段的规定范围内 1234567-- 给指定列添加数据 INSERT INTO 表名(列名1，列名2，……) VALUES(值1，值2，……);-- 给全部列添加数据 INSERT INTO 表名 VALUES(值1，值2，……);-- 批量添加 INSERT INTO 表名 (列1，列2，……) VALUES(值1，值2，……),(值1，值2，……)，……; INSERT INTO 表名 VALUES(值1，值2，……),(值1，值2，……)，……; 修改数据 1UPDATA 表名 SET 列名1 = 值1，列名2 = 值2，…… [WHERE 条件]； 注：修改语句中如果不加条件，将修改所有数据 删除数据 1DELETE FROM 表名[WHERE 条件]; DQL 数据查询语言 简介 DQL 数据查询语言( DATA QUERY LANGUAGE ) 查询数据库中表的记录（数据） 基础查询 123456789101112-- 查询多个字段SELECT 列名1，列名2，...FROM 表名;SELECT * FROM 表名;-- (直接查询全部)注：不建议使用第二种，使得代码可读性降低。-- 设置别名SELECT 字段1[AS 别名1],字段2[AS 别名2],... FROM 表名;-- AS可以省略-- 去除重复记录SELECT DISTINCT 字段列表 FROM 表名; 条件查询 WHERE SELECT 字段列表 FROM 表名 WHERE 条件列表； 条件 符号 功能 &gt;= 大于等于 &lt;= 小于等于 &lt; 小于 &gt; 大于 &lt;&gt; 或 != 不等于 = 等于 BETWEEN …AND… 在某个范围内 （数值范围从小到大，否则查询不到） AND 或 &amp;&amp; 并且 OR 或 || 或者 IN(…) 多选一 NOT 或 ！ 非，不是 IS NULL 是空 IS NOT NULL 非空 LIKE 占位符 模糊查询： _单个任意字符 %多个任意字符 | 注：NULL值得比较不能用= != ，需要用IS IS NOT; BETWEEN…AND和IN(…)区别：前者是取值范围内允许，后者是具体值选其一 排序查询 ORDER BY SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1[排序方式1] , 排序字段名2[排序方式2] , ……； 排序方式 - ASC：升序（默认） - DESC：降序 注：有多个条件时，当前边条件值一样时，才会根据第二个条件进行排序 分组查询 GROUP BY 聚合函数 概念： 将一列数据作为一个整体，纵向计算。所有NULL值不参与运算 分类 函数名 功能 COUNT(列名) 统计数量（一般不为NULL值） 列名取值：1. 主键 ，2. * MAX(列名) 最大值 MIN(列名) 最小值 SUM(列名) 求和 AVG(列名) 求平均 分组查询语法 SECLECT 聚合函数(字段列表) FROM 表名 [WHERE 分组前提条件限定] GROUP BY 分组字段名 [HAVING 分组后过滤条件]； 注：分组后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义。 WHERE 和 HAVING 的区别 执行时机不同：WHERE 时分组之前进行条件限定，不满足WHERE条件则不参与分组，而HAVING是分组后对结果进行过滤。 可判断的条件不同：WHERE 不能对聚合函数进行判断，HAVING 可以。 执行顺序：WHERE &gt; 聚合函数 &gt; HAVING 分页查询 LIMIT(MySQL专用) SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询条目数； 计算公式：起始索引 = （当前页码 - 1） 每页显示条数* 查询的执行顺序 FROM… -&gt;WHERE… -&gt;SELECT… -&gt;ORDER BY… -&gt;LIMIT… DCL 数据控制语言(不常用) 简介 DCL 数据控制语言( DATA CONTROL LANGUAGE ) 定义数据库的访问权限和安全级别，及创建用户 管理用户 查询用户 12USE 用户名;SELECT * FROM user; 创建用户 1CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;; 修改用户密码 1ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;; 删除用户 1DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; 权限控制 查询权限 1SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;; 授予权限 1GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;; 撤销权限 1REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;","tags":["MySQL"],"categories":["学习笔记"]},{"title":"关于本站","path":"/about/index.html","content":"尊敬的读者们： 欢迎来到我的个人博客。在创建网站的过程中，为丰富网站内容并提供多元化视角，作者在学习的过程中， 部分学习笔记等文章会整合互联网上各种优质资源，不限于 CSDN、OS China、掘金、Github等。 在此声明，一切文章仅为作者学习时笔记的整合和记录，无恶意搬运。 若有侵权，请立即联系作者删除。 如果您有任何疑问或者建议，欢迎您随时与我联系。邮箱：[3086660647@qq.com] 谢谢！ Echo"},{"title":"友链","path":"/friends/index.html","content":"还没挂友链"},{"title":"更多","path":"/more/index.html","content":"没有更多"}]