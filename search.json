[{"title":"b","path":"/2023/11/24/b/","content":"还行不是 啊 这 不是吧 哦哦"},{"title":"a","path":"/2023/11/23/a/","content":"我是一只小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的小小的","tags":["Java"],"categories":["技术随笔"]},{"title":"Redis基础篇","path":"/2023/11/08/Redis基础篇/","content":"1.Redis简单介绍Redis是一种键值型的NoSql数据库，这里有两个关键字： 键值型 NoSql 其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json。 而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。 对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。 2.初始Redis2.1.认识NoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 2.1.1.结构化与非结构化传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。 而NoSql则对数据库格式没有严格约束，往往形式松散，自由。 可以是键值型，也可以是文档型，甚至可以是图格式。 2.1.2.关联和非关联传统数据库的表与表之间往往存在关联，例如外键： 而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合： 123456789101112131415161718&#123; id: 1, name: &quot;张三&quot;, orders: [ &#123; id: 1, item: &#123; id: 10, title: &quot;荣耀6&quot;, price: 4999 &#125; &#125;, &#123; id: 2, item: &#123; id: 20, title: &quot;小米11&quot;, price: 3999 &#125; &#125; ]&#125; 此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。 2.1.3.查询方式传统关系型数据库会基于Sql语句做查询，语法有统一标准； 而不同的非关系数据库查询语法差异极大，五花八门各种各样。 2.1.4.事务传统关系型数据库能满足事务ACID的原则。 而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。 2.1.5.总结除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下： 存储方式 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些 扩展性 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦 2.2.认识RedisRedis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存.IO多路复用.良好的编码）。 支持数据持久化 支持主从集群.分片集群 支持多语言客户端 Redis的官方网站地址：https://redis.io/ 3.Redis常见命令3.1 Redis数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令，也可以执行该命令进入容器执行命令。 1docker exec -it &lt;container_name_or_id&gt; redis-cli 3.2 Redis 通用命令通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL(Time To Live，生存时间)：查看一个KEY的剩余有效期 通过help [command] 可以查看一个命令的具体用法。 代码如下 KEYS 123456789127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt; 提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 DEL 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1 #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;\t#只剩下一个了127.0.0.1:6379&gt; 提示：在拷贝代码的时候，只需要拷贝对应的命令 EXISTS 123456789101112127.0.0.1:6379&gt; help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE 提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除 1234567891011127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1 # ttl的返回值就是-1 3.3 Redis命令-String命令String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 String的常见命令有： SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（必须指定增长步长） SETNX(set not exit)：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX(set key expire time)：添加一个String类型的键值对，并且指定有效期 提示：以上命令除了INCRBYFLOAT 都是常用命令，且有一些组合命令如SETNX,SETEX. SET 和GET: 如果key不存在则是新增，如果存在则是修改 1234567891011127.0.0.1:6379&gt; set name Rose //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot; MSET和MGET 123456789127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot; //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot; INCR和INCRBY和DECY 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11 127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值 127.0.0.1:6379&gt; incrby age 2(integer) 15 127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14 127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12 127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11 127.0.0.1:6379&gt; get age &quot;11&quot; SETNX 1234567891011121314151617127.0.0.1:6379&gt; help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string127.0.0.1:6379&gt; set name Jack //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot; SETEX 12345678127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7 3.4 Redis命令-Key的层级结构Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下： **项目名：业务名：类型：id** 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于文件夹的结构，更加方便Redis获取数据。 3.5 Redis命令-Hash命令Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便；Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。 Hash类型的常见命令 HSET key field value：添加或者修改hash类型key的field的值 HGET key field：获取一个hash类型key的field的值 HMSET：批量获取多个hash类型key的field的值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有的field HVALS：获取一个hash类型的key中的所有的field的值 HINCRBY:让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 提示：哈希结构也是实际开发中常用的命令 HSET和HGET 12345678910127.0.0.1:6379&gt; HSET user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET user:3 age&quot;17&quot; HMSET和HMGET 12345678127.0.0.1:6379&gt; HMSET user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HGETALL 1234567127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot; HKEYS和HVALS 12345678127.0.0.1:6379&gt; HKEYS user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HINCRBY 12345678127.0.0.1:6379&gt; HINCRBY user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY user:4 age -2(integer) 20 HSETNX 12345678910111213141516127.0.0.1:6379&gt; HSETNX user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot; 3.6 Redis命令-List命令Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element … ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素，start表示起始索引，end表示结束索引 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil LPUSH和RPUSH 1234127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6 LPOP和RPOP 1234127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot; LRANGE 123127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot; 3.7 Redis命令-Set命令Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set类型的常见命令 SADD key member … ：向set中添加一个或多个元素 SREM key member … : 移除set中的指定元素 SCARD key： 返回set中元素的个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2 … ：求key1与key2的交集 SDIFF key1 key2 … ：求key1与key2的差集 SUNION key1 key2 ..：求key1和key2的并集 例如两个集合：s1和s2: 求交集：SINTER s1 s2 求s1与s2的不同：SDIFF s1 s2 具体命令 1234567891011121314151617127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1 127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0 127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1 127.0.0.1:6379&gt; SCARD s1(integer) 2 3.8 Redis命令-SortedSet类型Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member : 获取sorted set中的指定元素的score值 ZRANK key member：获取sorted set 中的指定元素的排名 ZCARD key：获取sorted set中的元素个数 ZCOUNT key min max：统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max：按照score排序后，获取指定排名范围内的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF.ZINTER.ZUNION：求差集.交集.并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 4.Redis的Java客户端-Jedis在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。 4.1 Jedis快速入门入门案例详细步骤 案例分析： 0）创建工程： 1）引入依赖： 12345678910111213&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）建立连接 新建一个单元测试类，内容如下： 123456789101112private Jedis jedis;@BeforeEachvoid setUp() &#123; // 1.建立连接 // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(&quot;123321&quot;); // 3.选择库 jedis.select(0);&#125; 3）测试： 1234567891011121314151617181920@Testvoid testString() &#123; // 存入数据 String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123; // 插入hash数据 jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;); jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;); // 获取 Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;); System.out.println(map);&#125;} 4）释放资源 123456@AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125;} 4.2 Jedis连接池Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如tomcat中的线程池，这些都是池化思想的体现。 4.2.1.创建Jedis的连接池1234567891011121314151617181920public class JedisConnectionFacotry &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;} 代码说明： 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，可以使用工厂，去降低耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3）最后提供返回连接池中连接的方法. 4.2.2.改造原始代码代码说明: 1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。 ，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。 2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。 123456789101112131415 @BeforeEach void setUp()&#123; //建立连接 /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); &#125;@AfterEach void tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;} 5.Redis的Java客户端-SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 5.1.快速入门SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 5.1.1.导入pom坐标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Jackson依赖，不引入springmvc的情况下，设置序列化器需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;} 5.1.2 .配置文件12345678910spring: redis: host: 192.168.150.101 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间} 5.1.3.测试代码123456789101112131415@SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test void testString() &#123; // 写入一条String数据 redisTemplate.opsForValue().set(&quot;name&quot;, &quot;那个谁&quot;); // 获取string数据 Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125;&#125;} 提示：SpringDataRedis使用起来非常简单，记住如下几个步骤即可 SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis信息 注入RedisTemplate 5.2 .数据序列化器RedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125;} 这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图： 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 5.3 StringRedisTemplate尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图： 为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass RedisStringTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() &#123; // 写入一条String数据 stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125; private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException &#123; // 创建对象 User user = new User(&quot;虎哥&quot;, 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(&quot;user1 = &quot; + user1); &#125;&#125;} 此时再来看存储的数据，就会发现那个class数据已经不在了，节约了我们的空间。 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象","tags":["Redis"],"categories":["学习笔记"]},{"title":"关于","path":"/about/index.html","content":""},{"title":"更多","path":"/more/index.html","content":"没有更多"},{"title":"友链","path":"/friends/index.html","content":"还没挂友链"}]