<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.0.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>JVM-类加载器 - 小破站</title>

  
    <meta name="description" content="类加载器的作用是将.class文件加载到内存中，并对类进行解释和校验。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-类加载器">
<meta property="og:url" content="https://strivingto.top/2023/12/25/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/index.html">
<meta property="og:site_name" content="小破站">
<meta property="og:description" content="类加载器的作用是将.class文件加载到内存中，并对类进行解释和校验。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.ibb.co/1GCsbPK/Snipaste-2023-12-23-20-25-49.png">
<meta property="og:image" content="https://i.ibb.co/5MdGR1g/Snipaste-2023-12-23-20-26-26.png">
<meta property="og:image" content="https://i.ibb.co/sJhYBjK/Snipaste-2023-12-23-20-44-25.png">
<meta property="og:image" content="https://i.ibb.co/XxPp7gj/Snipaste-2023-12-23-20-46-51.png">
<meta property="og:image" content="https://i.ibb.co/s6HJjxt/Snipaste-2023-12-23-20-49-31.png">
<meta property="og:image" content="https://i.ibb.co/hC0y7Mr/Snipaste-2023-12-23-21-00-11.png">
<meta property="og:image" content="https://i.ibb.co/Hh2SnrJ/Snipaste-2023-12-23-21-09-17.png">
<meta property="og:image" content="https://i.ibb.co/R9WcMYy/Snipaste-2023-12-23-21-20-12.png">
<meta property="og:image" content="https://i.ibb.co/x37ZQ5m/Snipaste-2023-12-23-21-44-15.png">
<meta property="og:image" content="https://i.ibb.co/KwyDJW7/Snipaste-2023-12-23-21-33-09.png">
<meta property="og:image" content="https://i.ibb.co/PNptXJH/Snipaste-2023-12-23-21-42-10.png">
<meta property="og:image" content="https://i.ibb.co/WkVHrzJ/Snipaste-2023-12-23-21-58-44.png">
<meta property="og:image" content="https://i.ibb.co/HxStwXV/Snipaste-2023-12-24-11-21-56.png">
<meta property="og:image" content="https://i.ibb.co/9wjTzfr/Snipaste-2023-12-24-11-29-09.png">
<meta property="og:image" content="https://i.ibb.co/XsVZSBy/Snipaste-2023-12-24-11-36-15.png">
<meta property="og:image" content="https://i.ibb.co/mzFx72k/Snipaste-2023-12-24-11-36-11.png">
<meta property="og:image" content="https://i.ibb.co/VHm2QH5/Snipaste-2023-12-24-11-50-46.png">
<meta property="og:image" content="https://i.ibb.co/BqhRXRF/Snipaste-2023-12-24-12-29-49.png">
<meta property="og:image" content="https://i.ibb.co/SmHHV0Q/Snipaste-2023-12-24-12-29-12.png">
<meta property="og:image" content="https://i.ibb.co/93fkN9d/Snipaste-2023-12-24-12-32-34.png">
<meta property="og:image" content="https://i.ibb.co/PCV9Xt1/Snipaste-2023-12-24-13-50-05.png">
<meta property="og:image" content="https://i.ibb.co/r7yQ8cC/Snipaste-2023-12-24-14-19-16.png">
<meta property="og:image" content="https://i.ibb.co/tK7W7mP/Snipaste-2023-12-24-14-19-28.png">
<meta property="og:image" content="https://i.ibb.co/ggpjGw2/Snipaste-2023-12-24-14-20-39.png">
<meta property="og:image" content="https://i.ibb.co/5h9QGm4/Snipaste-2023-12-24-14-43-41.png">
<meta property="og:image" content="https://i.ibb.co/3T6MHjH/Snipaste-2023-12-24-19-39-55.png">
<meta property="og:image" content="https://i.ibb.co/Njqs1Yj/Snipaste-2023-12-24-19-39-51.png">
<meta property="og:image" content="https://i.ibb.co/3T6MHjH/Snipaste-2023-12-24-19-39-55.png">
<meta property="og:image" content="https://i.ibb.co/2S9SZGN/Snipaste-2023-12-24-19-55-11.png">
<meta property="og:image" content="https://i.ibb.co/861FYnF/Snipaste-2023-12-24-20-44-27.png">
<meta property="og:image" content="https://i.ibb.co/gjtJ2Mp/Snipaste-2023-12-24-20-47-31.png">
<meta property="og:image" content="https://i.ibb.co/QbZ9Zy8/Snipaste-2023-12-24-20-43-43.png">
<meta property="og:image" content="https://i.ibb.co/V9pYjNh/Snipaste-2023-12-24-21-20-05.png">
<meta property="og:image" content="https://i.ibb.co/S3PHMrT/Snipaste-2023-12-24-21-33-25.png">
<meta property="og:image" content="https://i.ibb.co/gdLmNVS/Snipaste-2023-12-24-21-37-49.png">
<meta property="og:image" content="https://i.ibb.co/y091vGx/Snipaste-2023-12-24-21-49-20.png">
<meta property="og:image" content="https://i.ibb.co/HXD4Wvr/Snipaste-2023-12-24-21-51-43.png">
<meta property="og:image" content="https://i.ibb.co/JvqnxBT/Snipaste-2023-12-24-21-53-47.png">
<meta property="article:published_time" content="2023-12-25T02:42:23.000Z">
<meta property="article:modified_time" content="2024-01-03T12:01:14.027Z">
<meta property="article:author" content="Echo">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.ibb.co/1GCsbPK/Snipaste-2023-12-23-20-25-49.png">
  
  
  
  <meta name="keywords" content="JVM">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://i.ibb.co/t8bH857/avatar.png">
  

  

  


  
    
      <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet">
    
  
</head>

<body>
  

<div class="l_cover post"><div class="cover"><div class="lazy img bg" data-bg="https://source.unsplash.com/2000x400/?nature,beautiful"></div></div></div>


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://i.ibb.co/t8bH857/avatar.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Echo</div><div class="sub normal cap">种一棵树最好的时间是十年前</div><div class="sub hover cap" style="opacity:0"> 其次是现在</div></a></div>

<nav class="menu dis-select"><a class="nav-item" href="/more/">更多</a><a class="nav-item" href="/friends/">友链</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">JVM-类加载器</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">类加载器概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-text">类加载器作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Bootstrap-ClassLoader%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%A0%B8%E5%BF%83%E7%B1%BB%EF%BC%89"><span class="toc-text">启动类加载器 Bootstrap ClassLoader（加载核心类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Java 中的默认类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%89%A9%E5%B1%95%E7%B1%BB%EF%BC%89"><span class="toc-text">扩展类加载器 Extension（加载扩展类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Application%EF%BC%88%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8-classpath-%E4%B8%AD%E7%9A%84%E7%B1%BB-%EF%BC%89"><span class="toc-text">应用程序类加载器 Application（加载应用 classpath 中的类 ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arthas-%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84"><span class="toc-text">Arthas 查看类加载器的加载路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E4%B8%BB%E5%8A%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">Java 中主动加载类的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">双亲委派机制的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="toc-text">双亲委派机制的层次关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Arthas-%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">通过 Arthas 查看类加载器的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B8%B8%E8%80%83%E9%97%AE%E9%A2%98"><span class="toc-text">总结双亲委派机制的常考问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5"><span class="toc-text">案例引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ClassLoader-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">ClassLoader 源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">自定义类加载器的默认父类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-text">思考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">线程上下文类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC-%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5"><span class="toc-text">JDBC 案例引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI-%E6%9C%BA%E5%88%B6"><span class="toc-text">SPI 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">SPI获取应用程序类加载器流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Osgi-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E4%B8%8D%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">Osgi 框架的类加载器（不重要）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK9-%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">JDK9 之后的类加载器</span></a></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/GIMME-JIA" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/t8bH857/avatar.png"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-12-25T02:42:23.000Z">2023-12-25</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>JVM-类加载器</span></h1>
<h2 id="类加载器概述">类加载器概述</h2>
<ul>
<li>类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/1GCsbPK/Snipaste-2023-12-23-20-25-49.png"/></div></div>
<ul>
<li>类加载器只参与加载过程中的字节码获取并加载到内存这一部分。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/5MdGR1g/Snipaste-2023-12-23-20-26-26.png"/></div></div>
<h2 id="类加载器作用">类加载器作用</h2>
<ul>
<li>类加载器（ClassLoader）负责在类加载过程中的字节码获取并加载到内存这 一部分。通过加载字节码数据放入内存转换成byte[]，接下来调用虚拟机底层 方法将byte[]转换成方法区和堆中的数据。</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<ol>
<li>
<p><strong>SPI 机制</strong></p>
<ul>
<li>SPI（Service Provider Interface）是Java中一种基于接口的服务提供者机制，它允许开发者定义服务接口，而服务的实现则可以通过在类路径下的配置文件中指定。SPI机制是Java中实现可插拔组件的一种方式。SPI机制在Java标准库中广泛应用，比如JDBC。</li>
</ul>
</li>
<li>
<p><strong>类的热部署</strong></p>
<ul>
<li>类的热部署（Hot Deployment）是指在应用程序运行过程中，无需停止整个应用程序，而能够动态替换已加载的类文件，使得新的代码可以立即生效，而不必重新启动整个应用。这在开发和调试过程中非常有用，可以加速开发周期。如<strong>Java的动态类加载机制。</strong></li>
</ul>
</li>
<li>
<p><strong>Tomcat 类的隔离</strong></p>
<ul>
<li>在Tomcat中，类的隔离是指不同的Web应用程序（Web Context）之间的类加载和类实例之间的隔离。Tomcat采用了一种叫做&quot;Web Application ClassLoader&quot;的机制来实现类的隔离。</li>
<li>以下是Tomcat中类隔离的一些关键概念：
<ol>
<li><strong>Web Application ClassLoader：</strong> 每个Web应用程序在Tomcat中都有自己的类加载器，称为Web Application ClassLoader。这个类加载器负责加载Web应用程序中的类文件。</li>
<li><strong>父子关系：</strong> 在Tomcat的类加载器体系中，每个Web应用程序的类加载器都有一个父类加载器。通常情况下，Web应用程序的类加载器的父类加载器是Catalina ClassLoader，而Catalina ClassLoader的父类加载器是Common ClassLoader。这种层次结构确保了类的隔离。</li>
<li><strong>类加载顺序：</strong> 当一个Web应用程序需要加载类时，它首先尝试在自己的类路径下查找，如果找不到，就会委托给父类加载器。这样，类的加载从Web应用程序的类加载器一直到Common ClassLoader，最终到达Java虚拟机的引导类加载器。</li>
<li><strong>隔离的作用：</strong> 类的隔离确保了不同的Web应用程序可以拥有自己的类实例，避免了不同Web应用程序之间的类冲突。这种隔离性使得每个Web应用程序在运行时更加独立，不受其他Web应用程序的影响。</li>
<li><strong>共享类库：</strong> 除了各自的类加载器之外，Tomcat还提供了一个共享的类库目录（lib目录），其中的JAR文件中的类可以被所有的Web应用程序共享。这些共享的类库通常包括Tomcat自身的一些库和一些全局的库。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="类加载器的分类">类加载器的分类</h2>
<ul>
<li>类加载器分为两类，一类是 Java 代码中实现，一类是 Java 虚拟机底层源码 C++实现。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/sJhYBjK/Snipaste-2023-12-23-20-44-25.png"/></div></div>
<ul>
<li>类加载器的设计 JDK8 和 8 之后的版本差别较大，JDK8 及之前的版本中默认的类加载器有如下几种</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/XxPp7gj/Snipaste-2023-12-23-20-46-51.png"/></div></div>
<ul>
<li>类加载器的详细信息可以使用 Arthas 通过classloader命令查看：<strong>classloader - 查看</strong> classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/s6HJjxt/Snipaste-2023-12-23-20-49-31.png"/></div></div>
<h3 id="启动类加载器-Bootstrap-ClassLoader（加载核心类）">启动类加载器 Bootstrap ClassLoader（加载核心类）</h3>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）是由<strong>Hotspot虚拟 机提供的、使用C++编写的类加载器</strong>。</li>
<li><strong>默认加载Java安装目录/jre/lib下的类文件</strong>，比如rt.jar（包含 String 等），tools.jar，resources.jar等。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/hC0y7Mr/Snipaste-2023-12-23-21-00-11.png"/></div></div>
<ul>
<li>注意：因为启动类加载器是由Hotspot虚拟 机提供的、使用C++编写的类加载器，所以无法通过 Java 代码来获取。如：</li>
</ul>
<div class="tag-plugin note" color="green" child="codeblock"><div class="body"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> String.class.getClassLoader();	</span><br><span class="line">System.out.println(classLoader);	</span><br><span class="line"></span><br><span class="line"><span class="comment">// String.class 的类加载器是由引导类加载器（Bootstrap Class Loader）加载的。</span></span><br><span class="line"><span class="comment">// 引导类加载器是用本地代码实现的，不是一个普通的 Java 类，因此对于它来说，它的类加载器是 null。</span></span><br></pre></td></tr></table></figure></div></div>
<ul>
<li>使用 Arthas 通过命令<strong>sc -d [ 全限定类名 ]</strong> 来查看已加载的类信息</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/Hh2SnrJ/Snipaste-2023-12-23-21-09-17.png"/></div></div>
<ul>
<li><strong>通过启动类加载器去加载用户 jar 包</strong>
<ul>
<li>放入jre/lib下进行扩展
<ul>
<li>不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。</li>
</ul>
</li>
<li>使用参数进行扩展
<ul>
<li>推荐，使用 <strong>-Xbootclasspath/a:jar包目录/jar包名</strong> 进行扩展</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/R9WcMYy/Snipaste-2023-12-23-21-20-12.png"/></div></div>
<h3 id="Java-中的默认类加载器">Java 中的默认类加载器</h3>
<ul>
<li>扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。</li>
<li>它们的源码都位于<strong>sun.misc.Launcher</strong>中，是一个<strong>静态内部类</strong>。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/x37ZQ5m/Snipaste-2023-12-23-21-44-15.png"/></div></div>
<h4 id="扩展类加载器-Extension（加载扩展类）">扩展类加载器 Extension（加载扩展类）</h4>
<ul>
<li>扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。</li>
<li>默认加载Java安装目录 <strong>/jre/lib/ext</strong>下的类文件。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/KwyDJW7/Snipaste-2023-12-23-21-33-09.png"/></div></div>
<ul>
<li>通过扩展类加载器去加载用户jar包：
<ul>
<li>放入/jre/lib/ext下进行扩展
<ul>
<li>不推荐，尽可能不要去更改JDK安装目录中的内容</li>
</ul>
</li>
<li>使用参数进行扩展
<ul>
<li>推荐，使用 <strong>-Djava.ext.dirs=jar</strong>包目录 进行扩展,这种方式会覆盖掉原始目录，可以用；(windows):(macos/linux) 追加上原始目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/PNptXJH/Snipaste-2023-12-23-21-42-10.png"/></div></div>
<h4 id="应用程序类加载器-Application（加载应用-classpath-中的类-）">应用程序类加载器 Application（加载应用 classpath 中的类 ）</h4>
<ul>
<li>
<p>在Java中，应用程序类加载器（Application Class Loader），也称为系统类加载器（System Class Loader），是Java类加载器层次结构中的一部分，位于类加载器层次结构的第二层。</p>
</li>
<li>
<p>应用程序类加载器<strong>负责加载应用程序类路径（Classpath）上的类文件</strong>。在Java应用程序中，类文件通常存放在类路径下，而应用程序类加载器就是负责从这个类路径加载类文件的。应用程序类加载器是一种Java类，它实际上是<strong>sun.misc.Launcher$AppClassLoader</strong>类的实例。</p>
</li>
<li>
<p>应用程序类加载器的一些特点和行为包括：</p>
</li>
</ul>
<ol>
<li><strong>类路径加载：</strong> 应用程序类加载器负责加载<strong>类路径</strong>上的类文件。<strong>类路径包括系统类路径和用户类路径</strong>。</li>
<li><strong>父类加载器：</strong> 应用程序类加载器的父类加载器是扩展类加载器（Extension Class Loader）。扩展类加载器的父类加载器是引导类加载器（Bootstrap Class Loader）。</li>
<li><strong>自定义加载器：</strong> 通常，开发者可以通过自定义类加载器来扩展或修改类加载的行为。这些自定义加载器的父类加载器通常是应用程序类加载器。</li>
<li><strong>获取ClassLoader：</strong> 可以通过<strong>ClassLoader.getSystemClassLoader()</strong> 来获取应用程序类加载器的实例。</li>
</ol>
<h3 id="Arthas-查看类加载器的加载路径">Arthas 查看类加载器的加载路径</h3>
<ul>
<li>类加载器的加载路径可以通过 [<strong>classloader –c hash值</strong> ] 查看</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/WkVHrzJ/Snipaste-2023-12-23-21-58-44.png"/></div></div>
<h2 id="双亲委派机制">双亲委派机制</h2>
<h3 id="概念">概念</h3>
<ul>
<li>每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级，<strong>并不是继承关系</strong>。</li>
<li>所以双亲委派机制指的是：<strong>自底向上查找是否加载过，再有顶向下进行加载。</strong> 向上查找如果已经加载过，就直接返回 Class 对象，加载过程结束。这样避免一个类重复加载。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/HxStwXV/Snipaste-2023-12-24-11-21-56.png"/></div></div>
<h3 id="Java-中主动加载类的方式">Java 中主动加载类的方式</h3>
<ol>
<li>
<p>使用 Class.forName 方法，使用当前类的类加载器去加载指定的类。</p>
</li>
<li>
<p>通过 getClassLoader 方法获取到类加载器，通过类加载器的 loadClass 方法指定某个类加载器加载。</p>
</li>
</ol>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/9wjTzfr/Snipaste-2023-12-24-11-29-09.png"/></div></div>
<h3 id="双亲委派机制的作用">双亲委派机制的作用</h3>
<ol>
<li>
<p><strong>保证类加载的安全性</strong></p>
<ul>
<li>通过双亲委派机制避免恶意代码替换 JDK 中的核心类库，比如 java.lang.String，确保核心类库有的完整性和安全性了。</li>
</ul>
</li>
<li>
<p><strong>避免重复加载</strong></p>
<ul>
<li>双亲委派机制可以避免同一个类被多次加载。</li>
</ul>
</li>
</ol>
<h3 id="双亲委派机制的层次关系">双亲委派机制的层次关系</h3>
<ul>
<li><strong>应用程序类加载器的 parent 父类是扩展类加载器，而扩展类加载器的 parent 是空，因为启动类加载器是使用 C++编写的，无法从 Java 代码中获取，且启动类加载器没有父类。</strong> 但是在代码逻辑上，扩展类加载器依然会把启动类加载器当成父类加载器处理。如果类加载的parent为null，则会提交给启动类加载器处理。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/XsVZSBy/Snipaste-2023-12-24-11-36-15.png"/></div></div>		
<ul>
<li>从 ClassLoader 类中也可以看到，会定义一个 parent 加载器，表示层级关系</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/mzFx72k/Snipaste-2023-12-24-11-36-11.png"/></div></div>
<h4 id="通过-Arthas-查看类加载器的关系">通过 Arthas 查看类加载器的关系</h4>
<ul>
<li>在某个类进程下，类加载器的父子关系可以通过 <strong>classloader -t</strong>查看</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/VHm2QH5/Snipaste-2023-12-24-11-50-46.png"/></div></div>
<h3 id="总结双亲委派机制的常考问题">总结双亲委派机制的常考问题</h3>
<blockquote>
<ol>
<li>如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？
<ul>
<li>启动类加载器加载，根据双亲委派机制，它的优先级是最高的。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>在自己的项目中去创建一个 java.lang.String 类，会被加载吗？
<ul>
<li>不能，会交由启动类加载器加载在rt.jar包中的String类</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>这几个类加载器彼此之间存在关系吗？
<ul>
<li>应用类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但是会委派给启动类加载器加载</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>类的双亲委派机制是什么？</strong></li>
</ol>
<ul>
<li><strong>1、当一个类加载器去加载某个类的时候,会自底向上查找是否加载过,如果加载过就直接返回,如果一直到最顶层的类加载器都没有加载,再由顶向下进行加载。（概念）</strong></li>
<li><strong>2、应用程序类加载器的父类加载器是扩展类加载器,扩展类加载器的父类加载器是启动类加载器。（关系）</strong></li>
<li><strong>3、双亲委派机制的好处有两点:第一是避免恶意代码替换JDK中的核心类库,比如java.lang.String,确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。（作用）</strong></li>
</ul>
</blockquote>
<h2 id="打破双亲委派机制">打破双亲委派机制</h2>
<h3 id="自定义类加载器">自定义类加载器</h3>
<h4 id="案例引入">案例引入</h4>
<ul>
<li>一个Tomcat程序中是可以运行多个 Web 应用的，如果这两个应用中出现了相同限定名的类，比如 Servlet类， Tomcat 要保证这两个类都能加载并且它们应该是不同的类。</li>
<li>如果不打破双亲委派机制，当应用类加载器加载Web应用1中的 MyServlet 之后，Web 应用2中相同限定名的 MyServlet 类就无法被加载了。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/BqhRXRF/Snipaste-2023-12-24-12-29-49.png"/></div></div>
<ul>
<li>对此， Tomcat使用了自定义类加载器来实现应用之间类的隔离。每一个应用会有一个独立的类加载器加载对应的类。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/SmHHV0Q/Snipaste-2023-12-24-12-29-12.png"/></div></div>
<h4 id="ClassLoader-源码分析">ClassLoader 源码分析</h4>
<ul>
<li>ClassLoader 中包含了 4 个核心方法，<strong>双亲委派机制的核心代码就位于 loadClass 方法中</strong>。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/93fkN9d/Snipaste-2023-12-24-12-32-34.png"/></div></div>
<ul>
<li>loadClass 源码流程分析</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/PCV9Xt1/Snipaste-2023-12-24-13-50-05.png"/></div></div>
<h4 id="自定义类加载器的默认父类加载器">自定义类加载器的默认父类加载器</h4>
<ul>
<li>以JDK8为例，ClassLoader类中提供了构造方法设置parent的内容：</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/r7yQ8cC/Snipaste-2023-12-24-14-19-16.png"/></div></div>
<ul>
<li>这个构造方法由另外一个构造方法调用，其中父类加载器由 <strong>getSystemClassLoader</strong> 方法设置，该方法返回的是<strong>AppClassLoader</strong>。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/tK7W7mP/Snipaste-2023-12-24-14-19-28.png"/></div></div>
<ul>
<li>所以，<strong>自定义类加载器的父类类加载器是应用程序类加载器 AppClassLoader</strong>，个人认为这是以类加载器的层级划分的。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/ggpjGw2/Snipaste-2023-12-24-14-20-39.png"/></div></div>
<h4 id="思考题">思考题</h4>
<blockquote>
<ol>
<li>两个自定义类加载器加载相同的全限定类名的类，会不会冲突？</li>
</ol>
<ul>
<li><strong>不会冲突</strong>，在同一个 Java虚拟机中，只有<strong>相同的类加载器+相同的类的全限定类名</strong>才会被认为是同一个类。</li>
</ul>
</blockquote>
<ul>
<li>可以在 Arthas 中使用<strong>sc -d 类名</strong> 的方式查看集体情况</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/5h9QGm4/Snipaste-2023-12-24-14-43-41.png"/></div></div>
<blockquote>
<p>Tips：</p>
<ol>
<li>如果仅仅是想扩展类加载的渠道的话，那么不应该打破双亲委派机制，只用<strong>重写 findClass</strong>方法的时候去扩展即可，不需要更改 loadClass 方法中的双亲委派机制。</li>
<li>当自定义的类加载器打破了双亲委派机制的时候，这样一个类就能被多个类加载器加载多次了</li>
</ol>
</blockquote>
<h3 id="线程上下文类加载器">线程上下文类加载器</h3>
<h4 id="JDBC-案例引入">JDBC 案例引入</h4>
<ul>
<li>JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。</li>
<li>DriverManager类位于rt.jar包中，由启动类加载器加载。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/3T6MHjH/Snipaste-2023-12-24-19-39-55.png"/></div></div>
<ul>
<li>依赖中的mysql驱动对应的类，由应用程序类加载器来加载。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/Njqs1Yj/Snipaste-2023-12-24-19-39-51.png"/></div></div>
<ul>
<li>DriverManager属于<strong>rt.jar</strong>是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/3T6MHjH/Snipaste-2023-12-24-19-39-55.png"/></div></div>
<h4 id="SPI-机制">SPI 机制</h4>
<p>Service Provider Interface（SPI）机制是 Java 中一种用于实现组件之间松耦合的机制。在 JDBC 中，SPI 机制用于加载数据库驱动程序。<br />
下面是 JDBC SPI 机制的基本流程：</p>
<ol>
<li><strong>定义接口：</strong> JDBC 定义了一系列的接口，用于描述数据库访问的标准 API。其中，<strong>Driver</strong> 接口用于表示数据库驱动程序。</li>
</ol>
<div class="tag-plugin note" color="green" child="codeblock"><div class="body"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>
<ol start="2">
<li><strong>实现接口：</strong> 不同数据库供应商实现了这个接口，以提供对其特定数据库的访问。每个数据库供应商都会提供一个 JDBC 驱动程序（JAR 文件），其中包含了实现了 <strong>Driver</strong> 接口的具体类。</li>
</ol>
<div class="tag-plugin note" color="green" child="codeblock"><div class="body"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个数据库驱动程序的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDatabaseDriver</span> <span class="keyword">implements</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>
<ol start="3">
<li><strong>META-INF/services 目录：</strong> 在 JDBC 规范中规定，每个实现了 <strong>Driver</strong> 接口的数据库驱动程序都应该在其 JAR 文件的 <strong>META-INF/services</strong> 目录下提供一个名为 <strong>java.sql.Driver</strong> 的文件，该文件包含驱动程序的类名。</li>
</ol>
<p><strong>java.sql.Driver</strong> 文件内容如下：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/2S9SZGN/Snipaste-2023-12-24-19-55-11.png"/></div></div>
<ol>
<li><strong>DriverManager 加载驱动程序：</strong> 当应用程序需要连接到数据库时，它使用 <strong>DriverManager</strong> 类来获取数据库连接。<strong>DriverManager</strong> 通过查找 <strong>java.sql.Driver</strong> 文件，加载并实例化所有在该文件中列出的类。</li>
</ol>
<div class="tag-plugin note" color="green" child="codeblock"><div class="body"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载数据库驱动程序</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.example.MyDatabaseDriver&quot;</span>);</span><br></pre></td></tr></table></figure></div></div>
<p>上述代码将触发类加载器加载 <strong>MyDatabaseDriver</strong> 类，从而实例化这个驱动程序。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/861FYnF/Snipaste-2023-12-24-20-44-27.png"/></div></div>
<ol>
<li><strong>DriverManager 获取连接：</strong> 一旦驱动程序被加载，应用程序可以通过 <strong>DriverManager</strong> 获取数据库连接。</li>
</ol>
<div class="tag-plugin note" color="green" child="codeblock"><div class="body"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager</span><br><span class="line">		.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mydatabase://localhost:3306/mydb&quot;</span>, </span><br><span class="line">            <span class="string">&quot;username&quot;</span>, </span><br><span class="line">            <span class="string">&quot;password&quot;</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure></div></div>
<p>这里的 <strong>“jdbc:mydatabase://localhost:3306/mydb”</strong> 是数据库连接 URL，其中 <strong>“mydatabase”</strong> 是数据库驱动程序的协议部分。</p>
<h4 id="SPI获取应用程序类加载器流程">SPI获取应用程序类加载器流程</h4>
<ul>
<li>SPI中使用了线程上下文中保存的类加载器进行类的加载，这个类加载器一般是应用程序类加载器。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/gjtJ2Mp/Snipaste-2023-12-24-20-47-31.png"/></div></div>
<h4 id="总结">总结</h4>
<ol>
<li>启动类加载器加载DriverManager。</li>
<li>在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动。</li>
<li>SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。</li>
</ol>
<ul>
<li>这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/QbZ9Zy8/Snipaste-2023-12-24-20-43-43.png"/></div></div>
<h4 id="面试题">面试题</h4>
<blockquote>
<ol>
<li>JDBC案例中真的打破了双亲委派机制吗？</li>
</ol>
<ul>
<li>首先说答案：没有打破。对于一些觉得打破的说法：DriverManager属于<strong>rt.jar</strong>是启动类加载器加载的，而用户jar包中的驱动需要由应用类加载器加载，这个过程违背了双亲委派自下而上委派，自上而下加载的原则，所以觉得是打破了。但是在周志明的 Java 虚拟机里有明确说明，<strong>当没有重写 loadClass()方法，而是通过重写 findClass 来完成类加载时，是符合双亲委派规则的。</strong><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/V9pYjNh/Snipaste-2023-12-24-21-20-05.png"/></div></div></li>
</ul>
</blockquote>
<h3 id="Osgi-框架的类加载器（不重要）">Osgi 框架的类加载器（不重要）</h3>
<p>OSGi（Open Service Gateway Initiative）是一种用于构建模块化、可插拔、动态的Java应用程序的规范。OSGi 规范定义了一套框架，使得开发者可以将应用程序划分为小的、互相隔离的模块，称为“bundles”。每个模块（bundle）都有自己的类加载器、生命周期和依赖关系。</p>
<ul>
<li>它存在同级之间的类加载器的委托加载(打破了双亲委派)。OSGi还使用类加载器实现了热部署(服务不停止的情况下，动态地更新字节码文件到内存中)的功能。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/S3PHMrT/Snipaste-2023-12-24-21-33-25.png"/></div></div>
<ul>
<li>热部署解决案例</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/gdLmNVS/Snipaste-2023-12-24-21-37-49.png"/></div></div>
<p>注意：</p>
<pre><code>  1. 程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。 
  2. 使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。
</code></pre>
<h2 id="JDK9-之后的类加载器">JDK9 之后的类加载器</h2>
<ul>
<li>JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/y091vGx/Snipaste-2023-12-24-21-49-20.png"/></div></div>
<ul>
<li>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。</li>
</ul>
<ol>
<li>启动类加载器使用Java编写，位于<strong>jdk.internal.loader.ClassLoaders</strong>类中.Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。
<ul>
<li>启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</li>
</ul>
</li>
</ol>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/HXD4Wvr/Snipaste-2023-12-24-21-51-43.png"/></div></div>
<ol>
<li>扩展类加载器被替换成了平台类加载器（Platform Class Loader）。平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 URLClassLoader变成了 BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。</li>
</ol>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.ibb.co/JvqnxBT/Snipaste-2023-12-24-21-53-47.png"/></div></div>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/12/26/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">JVM-运行时数据区</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/12/25/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">JVM-类的生命周期</a></div></section></div>


<div class="related-wrap reveal" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="\2023\12\27\JVM-垃圾回收\" title="JVM-垃圾回收"><span class="title">JVM-垃圾回收</span></a><a class="item" href="\2023\12\24\JVM-字节码文件\" title="JVM-字节码文件"><span class="title">JVM-字节码文件</span><span class="excerpt">学习字节码文件的组成和常见的字节码指令，以及相关的字节码工具。</span></a><a class="item" href="\2023\12\26\JVM-运行时数据区\" title="JVM-运行时数据区"><span class="title">JVM-运行时数据区</span></a><a class="item" href="\2023\12\25\JVM-类的生命周期\" title="JVM-类的生命周期"><span class="title">JVM-类的生命周期</span><span class="excerpt">类的生命周期的认识。加载、连接(验证、准备、解析)、初始化、使用、卸载。</span></a><a class="item" href="\2023\05\22\MySQL-基础(1)\" title="MySQL-基础(1)"><span class="title">MySQL-基础(1)</span><span class="excerpt">MySQL数据库基础部分的学习笔记，SQL的基本认识。</span></a></div></section></div>





      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
